/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Animation/Animation.js":
/*!************************************!*\
  !*** ./src/Animation/Animation.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Animation\": () => (/* binding */ Animation)\n/* harmony export */ });\n/* harmony import */ var _Graphic_Frame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Graphic/Frame */ \"./src/Graphic/Frame.js\");\n/* harmony import */ var _Graphic_SpriteSheet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Graphic/SpriteSheet */ \"./src/Graphic/SpriteSheet.js\");\n\n\nclass Animation extends _Graphic_SpriteSheet__WEBPACK_IMPORTED_MODULE_1__.SpriteSheet {\n  /**\n   * Animation constructor.\n   *\n   * @param src\n   */\n  constructor(src) {\n    super(src); // Organize default values.\n\n    this.rate = 2;\n    this.loop = true;\n    this.isPlaying = false;\n    this.lastUpdate = new Date();\n    this.currentFrame = 0;\n  }\n  /**\n   * Creates a new Animation instance.\n   *\n   * @param src\n   * @returns {Animation}\n   */\n\n\n  static create(src) {\n    return new Animation(src);\n  }\n  /**\n   * Stops the animation.\n   */\n\n\n  stop() {\n    this.isPlaying = false;\n  }\n  /**\n   * Begin animation playback.\n   *\n   * @return this\n   */\n\n\n  play() {\n    if (!this.isPlaying) {\n      this.lastUpdate = new Date();\n      this.setFrame(0);\n    }\n\n    this.isPlaying = true;\n    return this;\n  }\n  /**\n   * Assigns the current frame.\n   *\n   * @param frame\n   * @returns {Animation}\n   */\n\n\n  setFrame(frame) {\n    this.currentFrame = frame;\n    return this;\n  }\n  /**\n   * Assigns whether or not the animation should loop.\n   *\n   * @param loop\n   * @returns {Animation}\n   */\n\n\n  setLoop(loop) {\n    this.loop = loop;\n    return this;\n  }\n  /**\n   * Returns whether or not the animation should loop.\n   *\n   * @returns {boolean}\n   */\n\n\n  getLoop() {\n    return this.loop;\n  }\n  /**\n   * Assigns the playback rate.\n   *\n   * @param rate\n   * @returns {Animation}\n   */\n\n\n  setRate(rate) {\n    this.rate = rate;\n    return this;\n  }\n  /**\n   * Returns the identifier for the current frame.\n   *\n   * @returns {number}\n   */\n\n\n  getCurrentFrame() {\n    return this.currentFrame;\n  }\n  /**\n   * Returns the current frame.\n   *\n   * @returns Frame\n   */\n\n\n  getFrame() {\n    if (this.currentFrame >= this.frames.length) {\n      return new _Graphic_Frame__WEBPACK_IMPORTED_MODULE_0__.Frame(0, 0, this.getDomResource().width, this.getDomResource().height);\n    }\n\n    return this.frames[this.currentFrame];\n  }\n  /**\n   * Indicates whether or not we're on the last frame.\n   *\n   * @returns {boolean}\n   */\n\n\n  isLastFrame() {\n    return this.currentFrame === this.frames.length - 1;\n  }\n  /**\n   * Updates the animation.\n   */\n\n\n  update() {\n    let frameNow = new Date();\n\n    if (!this.isPlaying) {\n      return this;\n    }\n\n    if (!this.frames.length) {\n      return this;\n    }\n\n    if (!this.getLoop() && this.isLastFrame()) {\n      this.isPlaying = false;\n      return this;\n    }\n\n    if (frameNow - this.lastUpdate > 1000 / this.rate) {\n      this.lastUpdate = frameNow;\n      this.currentFrame++;\n    }\n\n    if (this.currentFrame >= this.frames.length) {\n      this.currentFrame = 0;\n    }\n\n    return this;\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Animation/Animation.js?");

/***/ }),

/***/ "./src/Animation/KeyFrame.js":
/*!***********************************!*\
  !*** ./src/Animation/KeyFrame.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"KeyFrame\": () => (/* binding */ KeyFrame)\n/* harmony export */ });\n/* harmony import */ var _Math_Vector2f__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Math/Vector2f */ \"./src/Math/Vector2f.js\");\n\nclass KeyFrame {\n  /**\n   * KeyFrame constructor.\n   *\n   * @param value\n   * @param duration\n   */\n  constructor(value, duration) {\n    this.value = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_0__.Vector2f(0, 0);\n    this.duration = 1;\n    this.interpolation = 'Linear';\n    this.setDuration(duration).setValue(value);\n  }\n  /**\n   * Creates a new keyframe.\n   *\n   * @param value\n   * @param duration\n   * @returns {KeyFrame}\n   */\n\n\n  static create(value, duration) {\n    return new KeyFrame(value, duration);\n  }\n  /**\n   * Assigns the duration.\n   *\n   * @param duration\n   * @returns {KeyFrame}\n   */\n\n\n  setDuration(duration) {\n    this.duration = duration;\n    return this;\n  }\n  /**\n   * Assigns the value.\n   *\n   * @param value\n   * @returns {KeyFrame}\n   */\n\n\n  setValue(value) {\n    if (!value instanceof _Math_Vector2f__WEBPACK_IMPORTED_MODULE_0__.Vector2f) {\n      return this;\n    }\n\n    this.value = value;\n    return this;\n  }\n  /**\n   * Returns the duration.\n   *\n   * @returns {number}\n   */\n\n\n  getDuration() {\n    return this.duration;\n  }\n  /**\n   * Returns the value Vector.\n   *\n   * @returns {Vector2f}\n   */\n\n\n  getValue() {\n    return this.value;\n  }\n  /**\n   * Returns the interpolation method.\n   *\n   * @returns {string}\n   */\n\n\n  getInterpolation() {\n    return this.interpolation;\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Animation/KeyFrame.js?");

/***/ }),

/***/ "./src/Animation/Sequence.js":
/*!***********************************!*\
  !*** ./src/Animation/Sequence.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Sequence\": () => (/* binding */ Sequence)\n/* harmony export */ });\n/* harmony import */ var _KeyFrame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./KeyFrame */ \"./src/Animation/KeyFrame.js\");\n\nclass Sequence {\n  /**\n   * Sequence constructor.\n   */\n  constructor(mutator) {\n    this.keyFrames = [];\n    this.mutator = new Function();\n    this.currentFrame = 0;\n    this.lastFrame = new Date();\n    this.setMutator(mutator);\n  }\n  /**\n   * Creates a new Sequence instance.\n   *\n   * @param mutator\n   * @returns {Sequence}\n   */\n\n\n  static create(mutator) {\n    return new Sequence(mutator);\n  }\n  /**\n   * Returns the duration.\n   *\n   * @returns {number}\n   */\n\n\n  getDurationInSeconds() {\n    let sum = 0.00;\n    this.getKeyFrames().map(keyframe => {\n      sum += keyframe.getDuration();\n    });\n    return sum;\n  }\n  /**\n   * Assigns the mutator.\n   *\n   * @param mutator\n   * @returns {Sequence}\n   */\n\n\n  setMutator(mutator) {\n    if (!mutator instanceof Function()) {\n      return this;\n    }\n\n    this.mutator = mutator;\n    return this;\n  }\n  /**\n   * Returns the mutator.\n   *\n   * @returns {Function}\n   */\n\n\n  getMutator() {\n    return this.mutator;\n  }\n  /**\n   * Returns all assigned frames.\n   *\n   * @returns {Array}\n   */\n\n\n  getKeyFrames() {\n    return this.keyFrames;\n  }\n  /**\n   * Returns the current frame.\n   *\n   * @returns {number}\n   */\n\n\n  getCurrentFrame() {\n    return this.currentFrame;\n  }\n  /**\n   * Returns the count of key frames.\n   *\n   * @returns {number}\n   */\n\n\n  getKeyFrameCount() {\n    return this.getKeyFrames().length;\n  }\n  /**\n   * Returns the current frame itself.\n   *\n   * @returns {KeyFrame}\n   */\n\n\n  getKeyFrame() {\n    if (!this.hasCurrentFrame()) {\n      return new _KeyFrame__WEBPACK_IMPORTED_MODULE_0__.KeyFrame();\n    }\n\n    return this.getKeyFrames()[this.getCurrentFrame()];\n  }\n  /**\n   * Registers a new key frame.\n   *\n   * @param frame\n   * @returns {Sequence}\n   */\n\n\n  addKeyFrame(frame) {\n    if (!frame instanceof _KeyFrame__WEBPACK_IMPORTED_MODULE_0__.KeyFrame) {\n      return this;\n    }\n\n    this.keyFrames.push(frame);\n    return this;\n  }\n  /**\n   * Returns the last frame time.\n   *\n   * @returns {Date}\n   */\n\n\n  getLastFrameTime() {\n    return this.lastFrame;\n  }\n  /**\n   * Returns elapsed time in seconds.\n   *\n   * @returns {number}\n   */\n\n\n  getElapsedInSeconds() {\n    return (Date.now() - this.getLastFrameTime()) / 1000;\n  }\n  /**\n   * Indicates whether or not the current frame exists.\n   *\n   * @returns {boolean}\n   */\n\n\n  hasCurrentFrame() {\n    return this.getCurrentFrame() < this.getKeyFrameCount();\n  }\n  /**\n   * Executes the timeline mutator.\n   *\n   * @param value\n   */\n\n\n  call(value) {\n    if (this.getMutator() instanceof Function) {\n      this.getMutator()(value);\n    }\n  }\n  /**\n   * Processes the timeline sequence.\n   */\n\n\n  update() {\n    if (!this.getKeyFrame().getDuration()) {\n      return;\n    }\n\n    if (!this.hasCurrentFrame()) {\n      return;\n    } // Determine what the current value should be.\n\n\n    let percentage = this.getElapsedInSeconds() / this.getKeyFrame().getDuration();\n\n    if (percentage > 1) {\n      percentage = 1;\n    }\n\n    let offset = (this.getKeyFrame().getValue().getY() - this.getKeyFrame().getValue().getX()) * percentage;\n    let value = this.getKeyFrame().getValue().getX() + offset; // Execute the keyframe mutator.\n\n    this.call(value); // Increment the current frame.\n\n    if (this.getElapsedInSeconds() > this.getKeyFrame().getDuration()) {\n      this.currentFrame++;\n      this.lastFrame = new Date();\n    }\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Animation/Sequence.js?");

/***/ }),

/***/ "./src/Animation/Timeline.js":
/*!***********************************!*\
  !*** ./src/Animation/Timeline.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Timeline\": () => (/* binding */ Timeline)\n/* harmony export */ });\n/* harmony import */ var _Sequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sequence */ \"./src/Animation/Sequence.js\");\n\nclass Timeline {\n  /**\n   * Timeline constructor.\n   *\n   * @param sequences\n   */\n  constructor(sequences) {\n    this.sequences = [];\n    this.addSequences(sequences);\n  }\n  /**\n   * Creates a new timeline instance.\n   *\n   * @param sequences\n   * @returns {Timeline}\n   */\n\n\n  static create(sequences) {\n    return new Timeline(sequences);\n  }\n  /**\n   * Calculates the duration in seconds.\n   *\n   * @returns {number}\n   */\n\n\n  getDurationInSeconds() {\n    let max = 0;\n    this.getSequences().map(sequence => {\n      let duration = sequence.getDurationInSeconds();\n\n      if (duration > max) {\n        max = duration;\n      }\n    });\n    return max;\n  }\n  /**\n   * Returns the duration in milliseconds.\n   *\n   * @returns {number}\n   */\n\n\n  getDurationInMilliseconds() {\n    return this.getDurationInSeconds() * 1000;\n  }\n  /**\n   * Adds multiple sequences.\n   *\n   * @param sequences\n   * @returns {Timeline}\n   */\n\n\n  addSequences(sequences) {\n    if (!sequences) {\n      return this;\n    }\n\n    sequences.map(sequence => {\n      this.addSequence(sequence);\n    });\n    return this;\n  }\n  /**\n   * Adds a new sequence.\n   *\n   * @param sequence\n   * @returns {Timeline}\n   */\n\n\n  addSequence(sequence) {\n    if (!sequence instanceof _Sequence__WEBPACK_IMPORTED_MODULE_0__.Sequence) {\n      return this;\n    }\n\n    this.sequences.push(sequence);\n    return this;\n  }\n  /**\n   * Returns the sequences.\n   *\n   * @returns {Array}\n   */\n\n\n  getSequences() {\n    return this.sequences;\n  }\n  /**\n   * Executes each sequence.\n   */\n\n\n  update() {\n    const sequences = this.getSequences();\n\n    for (let i = 0; i < sequences.length; i++) {\n      sequences[i].update();\n    }\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Animation/Timeline.js?");

/***/ }),

/***/ "./src/Entity/AutoTile.js":
/*!********************************!*\
  !*** ./src/Entity/AutoTile.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AutoTile\": () => (/* binding */ AutoTile)\n/* harmony export */ });\n/* harmony import */ var _Math_Matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Math/Matrix */ \"./src/Math/Matrix.js\");\n/* harmony import */ var _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Math/Vector2f */ \"./src/Math/Vector2f.js\");\n\n\nclass AutoTile {\n  /**\n   * GroupedTile constructor.\n   *\n   * @param name\n   * @param tiles\n   */\n  constructor(name, tiles) {\n    this.name = name;\n    this.tiles = new _Math_Matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(3, 4));\n\n    if (tiles) {\n      this.setTiles(tiles);\n    }\n  }\n  /**\n   * Creates a new auto tile instance.\n   *\n   * @param name\n   * @param tiles\n   * @returns {AutoTile}\n   */\n\n\n  static create(name, tiles) {\n    return new AutoTile(name, tiles);\n  }\n  /**\n   * Automatically generates the auto tile map from a specific index.\n   *\n   * @param index The root frame index.\n   * @param area  The area of the tile map in tiles.\n   * @returns this\n   */\n\n\n  getFromIndex(index, area) {\n    for (let y = -2; y <= 1; y++) {\n      for (let x = -1; x <= 1; x++) {\n        this.setTile(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(x + 1, y + 2), index + y * area.getX() + x);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Assigns the name.\n   *\n   * @param name\n   * @returns {AutoTile}\n   */\n\n\n  setName(name) {\n    this.name = name;\n    return this;\n  }\n  /**\n   * Returns the name.\n   *\n   * @returns {*}\n   */\n\n\n  getName() {\n    return this.name;\n  }\n  /**\n   * Assigns the tiles matrix.\n   *\n   * @param tiles\n   * @returns {AutoTile}\n   */\n\n\n  setTiles(tiles) {\n    if (!tiles instanceof _Math_Matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix) {\n      return this;\n    }\n\n    this.tiles = tiles;\n    return this;\n  }\n  /**\n   * Returns the tiles matrix.\n   *\n   * @returns {Matrix}\n   */\n\n\n  getTiles() {\n    return this.tiles;\n  }\n  /**\n   * Returns a tile index at the specified position.\n   *\n   * @param position\n   * @returns {number}\n   */\n\n\n  getTile(position) {\n    return this.getTiles().getValue(position);\n  }\n  /**\n   * Assigns a tile index to the position.\n   *\n   * @param position\n   * @param tile\n   * @returns {AutoTile}\n   */\n\n\n  setTile(position, tile) {\n    this.getTiles().setValue(position, tile);\n    return this;\n  }\n  /**\n   * Returns whether or not the bitmasking value is valid based on this auto tile map.\n   *\n   * @param value\n   * @returns {boolean}\n   */\n\n\n  static isBitmaskValid(value) {\n    return ![1, 2, 4, 8, 6, 9].includes(value);\n  }\n  /**\n   * Indicates whether or not the bitmasking value indicates a floor tile (bottom row).\n   *\n   * @param value\n   * @returns {boolean}\n   */\n\n\n  static isBitmaskFloor(value) {\n    return [3, 5, 7].includes(value);\n  }\n  /**\n   * Indicates whether or not the bitmasking value indicates a ceiling tile (second row).\n   *\n   * @param value\n   * @returns {boolean}\n   */\n\n\n  static isBitmaskCeiling(value) {\n    return [10, 12, 14].includes(value);\n  }\n  /**\n   * Returns the root tile index.\n   *\n   * @returns {number}\n   */\n\n\n  getRootTile() {\n    return this.getTile(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(1, 2));\n  }\n  /**\n   * Indicates whether or not a tile exists.\n   *\n   * @param index\n   * @returns {boolean}\n   */\n\n\n  hasTile(index) {\n    for (let i = 0; i < this.getTiles().getData().length; i++) {\n      for (let j = 0; j < this.getTiles().getData()[i].length; j++) {\n        if (this.getTiles().getData()[i][j] === index) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Casts the tile series to an array.\n   *\n   * @returns {Array}\n   */\n\n\n  toArray() {\n    let tiles = [];\n\n    for (let i = 0; i < this.getTiles().getData().length; i++) {\n      for (let j = 0; j < this.getTiles().getData()[i].length; j++) {\n        tiles.push(this.getTiles().getData()[i][j]);\n      }\n    }\n\n    return tiles;\n  }\n  /**\n   * Returns the appropriate tile from a bitmasking value.\n   *\n   * @param value\n   * @see https://gamedevelopment.tutsplus.com/tutorials/how-to-use-tile-bitmasking-to-auto-tile-your-level-layouts--cms-25673\n   */\n\n\n  getFromBitmask(value) {\n    if (!AutoTile.isBitmaskValid(value)) {\n      return this.getRootTile();\n    }\n\n    switch (value) {\n      // No neighbors.\n      case 0:\n        return this.getTile(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(0, 0));\n      // Bottom right.\n\n      case 3:\n        return this.getTile(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(2, 3));\n      // Bottom left.\n\n      case 5:\n        return this.getTile(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(0, 3));\n      // Bottom.\n\n      case 7:\n        return this.getTile(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(1, 3));\n      // Top right.\n\n      case 10:\n        return this.getTile(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(2, 1));\n      // Right.\n\n      case 11:\n        return this.getTile(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(2, 2));\n      // Top left.\n\n      case 12:\n        return this.getTile(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(0, 1));\n      // Left.\n\n      case 13:\n        return this.getTile(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(0, 2));\n      // Top.\n\n      case 14:\n        return this.getTile(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(1, 1));\n      // All neighbors.\n\n      case 15:\n        return this.getRootTile();\n    }\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Entity/AutoTile.js?");

/***/ }),

/***/ "./src/Entity/Emitter.js":
/*!*******************************!*\
  !*** ./src/Entity/Emitter.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Emitter\": () => (/* binding */ Emitter)\n/* harmony export */ });\n/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite */ \"./src/Entity/Sprite.js\");\n/* harmony import */ var _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Math/Vector2f */ \"./src/Math/Vector2f.js\");\n/* harmony import */ var _Graphic_Particle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Graphic/Particle */ \"./src/Graphic/Particle.js\");\n\n\n\nclass Emitter extends _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite {\n  /**\n   * Emitter constructor.\n   *\n   * @param init\n   * @param rate\n   * @param max\n   */\n  constructor(init, rate, max) {\n    super(); // Organize emitter defaults.\n\n    this.init = init;\n    this.rate = rate || 1;\n    this.particles = [];\n    this.maxParticles = max || 5; // Frame-specific values.\n\n    this.loop = true;\n    this.isPlaying = false;\n    this.lastUpdate = new Date();\n    this.static = true;\n    this.solid = false;\n  }\n  /**\n   * Create a new emitter instance.\n   *\n   * @param init\n   * @param rate\n   * @param max\n   * @returns {Emitter}\n   */\n\n\n  static create(init, rate, max) {\n    return new Emitter(init, rate, max);\n  }\n  /**\n   * Returns the initializer.\n   *\n   * @returns {Function}\n   */\n\n\n  getInit() {\n    return this.init;\n  }\n  /**\n   * Returns the rate.\n   *\n   * @returns {number}\n   */\n\n\n  getRate() {\n    return this.rate;\n  }\n  /**\n   * Used to generate a new particle.\n   *\n   * @returns {Emitter}\n   */\n\n\n  addParticle() {\n    if (!this.init instanceof Function) {\n      return this;\n    }\n\n    let result = this.getInit()(this);\n\n    switch (true) {\n      case result instanceof _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite:\n        this.particles.push(new _Graphic_Particle__WEBPACK_IMPORTED_MODULE_2__.Particle(this.getInit()(this), 5000));\n        break;\n\n      case result instanceof _Graphic_Particle__WEBPACK_IMPORTED_MODULE_2__.Particle:\n        this.particles.push(result);\n        break;\n    }\n\n    return this;\n  }\n  /**\n   * Returns all particles.\n   *\n   * @returns {Array}\n   */\n\n\n  getParticles() {\n    return this.particles;\n  }\n  /**\n   * Returns the max particle limit.\n   *\n   * @returns {number}\n   */\n\n\n  getMaxParticles() {\n    return this.maxParticles;\n  }\n  /**\n   * Returns the count of live particles.\n   *\n   * @returns {*}\n   */\n\n\n  getCount() {\n    return this.getParticles().length;\n  }\n  /**\n   * Assigns the playing status.\n   *\n   * @param flag\n   * @returns {Emitter}\n   */\n\n\n  setPlaying(flag) {\n    this.isPlaying = flag;\n    return this;\n  }\n  /**\n   * Returns a new instance for cloning.\n   *\n   * @returns {Emitter}\n   */\n\n\n  getInstance() {\n    return new Emitter(this.getInit(), this.getRate(), this.getMaxParticles());\n  }\n  /**\n   * Indicate that we have child elements.\n   *\n   * @returns {boolean}\n   */\n\n\n  hasChildren() {\n    return true;\n  }\n  /**\n   * Used to identify whether or not the emitter is set to loop.\n   *\n   * @returns {boolean}\n   */\n\n\n  getLoop() {\n    return this.loop;\n  }\n  /**\n   * Starts playing the emitter.\n   *\n   * @returns {Emitter}\n   */\n\n\n  play() {\n    return this.setPlaying(true);\n  }\n  /**\n   * Stops playback.\n   *\n   * @returns {Emitter}\n   */\n\n\n  stop() {\n    return this.setPlaying(false);\n  }\n  /**\n   * Renders each particle.\n   */\n\n\n  draw() {\n    this.getParticles().map((particle, index) => {\n      const entity = particle.getSprite();\n\n      if (entity.getZIndex() !== _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.getZCurrent()) {\n        return;\n      }\n\n      if (!particle.isAlive()) {\n        this.particles.splice(index, 1);\n        return;\n      }\n\n      entity.setOffset(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(this.getOffset().getX() + entity.getPosition().getX() * (this.getScale().getX() - 1), this.getOffset().getY() + entity.getPosition().getY() * (this.getScale().getY() - 1)));\n      particle.draw();\n    }); // Since emitters are run through each step of the Z index priority range, we'll only process the timeline and\n    // frame updates once in that series. To do so, we can just check that the current index is the start value.\n    //\n\n    if (_Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.getZCurrent() !== _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.getZRange().getX()) {\n      return;\n    }\n\n    this.getTimeline().update();\n    let frameNow = new Date();\n\n    if (this.getCount() >= this.getMaxParticles()) {\n      return;\n    }\n\n    if (frameNow - this.lastUpdate > 1000 / this.getRate()) {\n      this.lastUpdate = frameNow;\n\n      if (this.isPlaying) {\n        this.addParticle();\n      }\n    }\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Entity/Emitter.js?");

/***/ }),

/***/ "./src/Entity/Sprite.js":
/*!******************************!*\
  !*** ./src/Entity/Sprite.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Sprite\": () => (/* binding */ Sprite)\n/* harmony export */ });\n/* harmony import */ var _Kernel_State__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Kernel/State */ \"./src/Kernel/State.js\");\n/* harmony import */ var _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Math/Vector2f */ \"./src/Math/Vector2f.js\");\n/* harmony import */ var _Math_Vector4f__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Math/Vector4f */ \"./src/Math/Vector4f.js\");\n/* harmony import */ var _Animation_Timeline__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Animation/Timeline */ \"./src/Animation/Timeline.js\");\n/* harmony import */ var _Animation_Animation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Animation/Animation */ \"./src/Animation/Animation.js\");\n/* harmony import */ var _Event_DistancePayload__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Event/DistancePayload */ \"./src/Event/DistancePayload.js\");\n/* harmony import */ var _Event_CollisionPayload__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Event/CollisionPayload */ \"./src/Event/CollisionPayload.js\");\n/* harmony import */ var _Event_RenderBeforePayload__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Event/RenderBeforePayload */ \"./src/Event/RenderBeforePayload.js\");\n\n\n\n\n\n\n\n\nclass Sprite {\n  /**\n   * Various behavioral flags.\n   *\n   * @type {Object}\n   */\n  static flags = {\n    ShowCollisions: false,\n    DetectionWindow: 100\n  };\n  /**\n   * The index boundaries.\n   *\n   * @type Vector2f\n   */\n\n  static zRange = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(0, 0);\n  /**\n   * Indicates the current Z priority.\n   *\n   * @type {number}\n   */\n\n  static zCurrent = 0;\n  /**\n   * Sprite constructor.\n   */\n\n  constructor(src, frame) {\n    // THe default attribute pool.\n    this.attributes = {\n      'Health': 100,\n      'MaxHealth': 100\n    }; // The default event stack.\n\n    this.events = {\n      'Collide': [],\n      'Distance': [],\n      'RenderAfter': [],\n      'RenderBefore': []\n    }; // The cache storage location.\n\n    this.cache = {}; // Behavioral flags.\n\n    this.solid = false;\n    this.static = false;\n    this.visible = true;\n    this.behavior = null;\n    this.collisionRect = null; // Properties used for rendering.\n\n    this.flipX = false;\n    this.flipY = false;\n    this.zIndex = 0;\n    this.opacity = 1; // Properties used for animations.\n\n    this.timeline = new _Animation_Timeline__WEBPACK_IMPORTED_MODULE_3__.Timeline();\n    this.direction = 'Down';\n    this.animations = {};\n    this.currentAnimation = null; // Properties used for positioning.\n\n    this.scale = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(1, 1);\n    this.offset = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(0, 0);\n    this.position = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(0, 0);\n    this.acceleration = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(0.0, 0.0);\n    this.maxAcceleration = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(1.0, 1.0);\n\n    if (src) {\n      // Include a default animation to cover the whole frame for static entities that only include an image.\n      this.addAnimation('Default', new _Animation_Animation__WEBPACK_IMPORTED_MODULE_4__.Animation(src).addFrame(frame));\n    }\n  }\n  /**\n   * Returns a new Sprite instance.\n   *\n   * @param src\n   * @param frame\n   * @returns {Sprite}\n   */\n\n\n  static create(src, frame) {\n    return new Sprite(src, frame);\n  }\n  /**\n   * Returns all available flags.\n   *\n   * @returns {Object}\n   */\n\n\n  static getFlags() {\n    return Sprite.flags;\n  }\n  /**\n   * Indicates whether or not a flag exists.\n   *\n   * @param flag\n   * @returns {boolean}\n   */\n\n\n  static hasFlag(flag) {\n    return Sprite.getFlags().hasOwnProperty(flag);\n  }\n  /**\n   * Returns the specified flag.\n   *\n   * @param flag\n   * @returns {*}\n   */\n\n\n  static getFlag(flag) {\n    if (!Sprite.hasFlag(flag)) {\n      return false;\n    }\n\n    return Sprite.getFlags()[flag];\n  }\n  /**\n   * Returns the current draw priority.\n   *\n   * @returns {number}\n   */\n\n\n  static getZCurrent() {\n    return Sprite.zCurrent;\n  }\n  /**\n   * Assigns the current draw priority.\n   *\n   * @param z\n   */\n\n\n  static setZCurrent(z) {\n    Sprite.zCurrent = z;\n    _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().setCanvasLayer(Math.floor(z / 10));\n  }\n  /**\n   * Returns the Z index boundaries.\n   *\n   * @returns {Vector2f}\n   */\n\n\n  static getZRange() {\n    return Sprite.zRange;\n  }\n  /**\n   * Flushes the cache.\n   *\n   * @param keys\n   * @returns this\n   */\n\n\n  flushCache(keys) {\n    if (keys && keys.length) {\n      for (let i = 0; i < keys.length; i++) {\n        if (this.getCache().hasOwnProperty(keys[i])) {\n          delete this.cache[keys[i]];\n        }\n      }\n\n      return this;\n    }\n\n    this.cache = {};\n    return this;\n  }\n  /**\n   * Returns the cache collection.\n   *\n   * @returns {{}}\n   */\n\n\n  getCache() {\n    return this.cache;\n  }\n  /**\n   * Assigns the cache key.\n   *\n   * @param key\n   * @param value\n   * @returns {Sprite}\n   */\n\n\n  setCacheKey(key, value) {\n    this.cache[key] = value;\n    return this;\n  }\n  /**\n   * Indicates whether or not a cache key exists.\n   *\n   * @param key\n   * @returns {boolean}\n   */\n\n\n  hasCacheKey(key) {\n    return this.getCache().hasOwnProperty(key);\n  }\n  /**\n   * Returns a cached element.\n   *\n   * @param key\n   * @returns {*}\n   */\n\n\n  getCacheKey(key) {\n    return this.hasCacheKey(key) ? this.getCache()[key] : null;\n  }\n  /**\n   * Assigns a Z index to the sprite.\n   *\n   * @param zIndex\n   * @returns {Sprite}\n   */\n\n\n  setZIndex(zIndex) {\n    this.zIndex = zIndex;\n\n    if (zIndex > Sprite.getZRange().getY()) {\n      Sprite.getZRange().setY(zIndex);\n    }\n\n    if (zIndex < Sprite.getZRange().getX()) {\n      Sprite.getZRange().setX(zIndex);\n    }\n\n    return this;\n  }\n  /**\n   * Returns the Z index for the sprite.\n   *\n   * @returns {number}\n   */\n\n\n  getZIndex() {\n    return this.zIndex;\n  }\n  /**\n   * Returns whether or not the entity has health.\n   *\n   * @returns {boolean}\n   */\n\n\n  isAlive() {\n    return this.getAttribute('Health') > 0;\n  }\n  /**\n   * Used to flip the sprite horizontally.\n   *\n   * @param flag\n   * @returns {Sprite}\n   */\n\n\n  setFlipX(flag) {\n    if (this.flipX !== flag) {\n      this.flipX = flag;\n      this.flushCache();\n    }\n\n    return this;\n  }\n  /**\n   * Indicates whether or not the sprite is being flipped horizontally.\n   *\n   * @returns {boolean}\n   */\n\n\n  getFlipX() {\n    return this.flipX;\n  }\n  /**\n   * Used to flip the sprite vertically.\n   *\n   * @param flag\n   * @returns {Sprite}\n   */\n\n\n  setFlipY(flag) {\n    if (this.flipY !== flag) {\n      this.flipY = flag;\n      this.flushCache();\n    }\n\n    return this;\n  }\n  /**\n   * Indicates whether or not the sprite is being flipped vertically.\n   *\n   * @returns {boolean}\n   */\n\n\n  getFlipY() {\n    return this.flipY;\n  }\n  /**\n   * Indicates whether or not the sprite is being flipped in general.\n   *\n   * @returns {boolean}\n   */\n\n\n  isFlipped() {\n    return this.getFlipX() || this.getFlipY();\n  }\n  /**\n   * Assigns the opacity.\n   *\n   * @param opacity\n   * @returns {Sprite}\n   */\n\n\n  setOpacity(opacity) {\n    this.opacity = opacity;\n    return this;\n  }\n  /**\n   * Returns the opacity.\n   *\n   * @returns {number}\n   */\n\n\n  getOpacity() {\n    return this.opacity;\n  }\n  /**\n   * Assigns the static flag.\n   *\n   * @param flag\n   * @returns {Sprite}\n   */\n\n\n  setStatic(flag) {\n    this.static = flag;\n    return this;\n  }\n  /**\n   * Returns the static flag.\n   *\n   * @returns {boolean}\n   */\n\n\n  getStatic() {\n    return this.static;\n  }\n  /**\n   * Assigns the behavior for the sprite.\n   *\n   * @param behavior\n   * @returns this\n   */\n\n\n  setBehavior(behavior) {\n    if (!behavior instanceof Function) {\n      return this;\n    }\n\n    this.behavior = behavior;\n    return this;\n  }\n  /**\n   * Returns the configured behavior.\n   *\n   * @returns {Function}\n   */\n\n\n  getBehavior() {\n    return this.behavior;\n  }\n  /**\n   * Executes the behavioral callback.\n   *\n   * @returns this\n   */\n\n\n  behave() {\n    if (this.getBehavior()) {\n      this.getBehavior()(this);\n    }\n\n    return this;\n  }\n  /**\n   * Assigns a dynamic attribute.\n   *\n   * @param name\n   * @param value\n   * @returns this\n   */\n\n\n  setAttribute(name, value) {\n    value = value || null;\n    this.attributes[name] = value;\n    return this;\n  }\n  /**\n   * Returns all dynamic attributes.\n   *\n   * @returns {*}\n   */\n\n\n  getAttributes() {\n    return this.attributes;\n  }\n  /**\n   * Returns a dynamic attribute.\n   *\n   * @param name\n   * @param fallback\n   * @returns {*}\n   */\n\n\n  getAttribute(name, fallback) {\n    fallback = fallback || 0;\n\n    if (!this.getAttributes().hasOwnProperty(name)) {\n      return fallback;\n    }\n\n    return this.attributes[name] || fallback;\n  }\n  /**\n   * Assigns the solid flag to a tile.\n   *\n   * @param flag\n   * @returns this\n   */\n\n\n  setSolid(flag) {\n    this.solid = flag;\n    return this;\n  }\n  /**\n   * Indicates whether or not the tile is solid.\n   *\n   * @returns {boolean}\n   */\n\n\n  getSolid() {\n    return this.solid;\n  }\n  /**\n   * Identifies whether or not events exist.\n   *\n   * @returns {boolean}\n   */\n\n\n  hasEvents() {\n    for (let i in this.getEvents()) {\n      if (!this.getEvents().hasOwnProperty(i)) {\n        continue;\n      }\n\n      if (this.getEvents()[i].length) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Executes the pre-render event.\n   *\n   * @param payload\n   */\n\n\n  onRenderBefore(payload) {\n    this.callEvents('RenderBefore', payload);\n  }\n  /**\n   * Executes the post-render event.\n   *\n   * @param payload\n   */\n\n\n  onRenderAfter(payload) {\n    this.callEvents('RenderAfter', payload);\n  }\n  /**\n   * Executes any distance events.\n   *\n   * @param payload\n   */\n\n\n  onDistance(payload) {\n    this.callEvents('Distance', payload);\n  }\n  /**\n   * Executes any collision events.\n   *\n   * @param payload\n   */\n\n\n  onCollide(payload) {\n    this.callEvents('Collide', payload);\n  }\n  /**\n   * Runs the target event stack.\n   *\n   * @param location\n   * @param payload\n   * @returns {Sprite}\n   */\n\n\n  callEvents(location, payload) {\n    if (!this.events.hasOwnProperty(location)) {\n      return this;\n    }\n\n    this.events[location].map(event => {\n      event(payload);\n    });\n  }\n  /**\n   * Returns all assigned events.\n   *\n   * @returns Object\n   */\n\n\n  getEvents() {\n    return this.events;\n  }\n  /**\n   * Binds a new event.\n   *\n   * @param location\n   * @param callback\n   * @returns {Sprite}\n   */\n\n\n  addEvent(location, callback) {\n    if (!callback instanceof Function) {\n      return this;\n    }\n\n    if (!this.events.hasOwnProperty(location)) {\n      this.events[location] = [];\n    }\n\n    this.events[location].push(callback);\n    return this;\n  }\n  /**\n   * Returns the assigned direction.\n   *\n   * @returns {string}\n   */\n\n\n  getDirection() {\n    return this.direction;\n  }\n  /**\n   * Assigns the facing direction.\n   *\n   * @param direction\n   * @returns {Sprite}\n   */\n\n\n  setDirection(direction) {\n    this.direction = direction;\n    return this;\n  }\n  /**\n   * Returns the offset.\n   *\n   * @returns Vector2f\n   */\n\n\n  getOffset() {\n    return this.offset;\n  }\n  /**\n   * Assigns the offset.\n   *\n   * @param offset\n   * @returns this\n   */\n\n\n  setOffset(offset) {\n    if (!offset instanceof _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f) {\n      return this;\n    }\n\n    this.flushCache();\n    this.offset = offset;\n    return this;\n  }\n  /**\n   * Returns the scale.\n   *\n   * @returns Vector2f\n   */\n\n\n  getScale() {\n    return this.scale;\n  }\n  /**\n   * Assigns the scale.\n   *\n   * @param scale\n   * @returns this\n   */\n\n\n  setScale(scale) {\n    if (!scale instanceof _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f) {\n      return this;\n    }\n\n    this.scale = scale;\n    return this;\n  }\n  /**\n   * Assigns the current position.\n   *\n   * @param position\n   * @returns {Sprite}\n   */\n\n\n  setPosition(position) {\n    if (!position instanceof _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f) {\n      return this;\n    }\n\n    this.position = position;\n    this.flushCache();\n    return this;\n  }\n  /**\n   * Returns the current position.\n   *\n   * @returns Vector2f\n   */\n\n\n  getPosition() {\n    return this.position;\n  }\n  /**\n   * Returns the acceleration.\n   *\n   * @returns Vector2f\n   */\n\n\n  getAcceleration() {\n    return this.acceleration;\n  }\n  /**\n   * Assigns the acceleration.\n   *\n   * @param acceleration\n   * @returns this\n   */\n\n\n  setAcceleration(acceleration) {\n    if (!acceleration instanceof _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f) {\n      return this;\n    }\n\n    this.acceleration = acceleration;\n    return this;\n  }\n  /**\n   * Assigns the max acceleration.\n   *\n   * @param acceleration\n   * @returns {Sprite}\n   */\n\n\n  setMaxAcceleration(acceleration) {\n    this.maxAcceleration = acceleration;\n    return this;\n  }\n  /**\n   * Returns the max acceleration.\n   *\n   * @returns Vector2f\n   */\n\n\n  getMaxAcceleration() {\n    return this.maxAcceleration;\n  }\n  /**\n   * Registers a new animation.\n   *\n   * @param name\n   * @param animation\n   * @returns this\n   */\n\n\n  addAnimation(name, animation) {\n    if (!animation instanceof _Animation_Animation__WEBPACK_IMPORTED_MODULE_4__.Animation) {\n      return this;\n    }\n\n    this.animations[name] = animation;\n\n    if (!this.currentAnimation) {\n      this.currentAnimation = name;\n    }\n\n    return this;\n  }\n  /**\n   * Indicates whether or not animations have been assigned.\n   *\n   * @returns boolean\n   */\n\n\n  hasAnimations() {\n    return !!Object.keys(this.getAnimations()).length;\n  }\n  /**\n   * Indicates whether or not an animation exists.\n   *\n   * @param name\n   */\n\n\n  hasAnimation(name) {\n    return this.getAnimations().hasOwnProperty(name);\n  }\n  /**\n   * Assigns the current animation.\n   *\n   * @param name\n   * @returns {Sprite}\n   */\n\n\n  setAnimation(name) {\n    this.currentAnimation = name;\n    this.getAnimation().play();\n    return this;\n  }\n  /**\n   * Returns all animations.\n   *\n   * @returns Object\n   */\n\n\n  getAnimations() {\n    return this.animations;\n  }\n  /**\n   * Returns the current animation name.\n   *\n   * @returns {null}\n   */\n\n\n  getAnimationName() {\n    return this.currentAnimation;\n  }\n  /**\n   * Returns the active animation.\n   *\n   * @returns Animation\n   */\n\n\n  getAnimation() {\n    if (!this.getAnimationName()) {\n      return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_4__.Animation();\n    }\n\n    if (!this.getAnimations().hasOwnProperty(this.getAnimationName())) {\n      return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_4__.Animation();\n    }\n\n    return this.getAnimations()[this.getAnimationName()];\n  }\n  /**\n   * Returns the scaled size.\n   *\n   * @returns {Vector2f}\n   */\n\n\n  getScaledSize() {\n    return new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(this.getAnimation().getFrame().getW() * this.getScale().getX(), this.getAnimation().getFrame().getH() * this.getScale().getY());\n  }\n  /**\n   * Returns the final scaled sprite size.\n   *\n   * @returns {Vector2f}\n   */\n\n\n  getCalculatedSize() {\n    if (!this.hasCacheKey('CalculatedSize')) {\n      let scaledSize = this.getScaledSize();\n      this.setCacheKey('CalculatedSize', new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(_Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().scale(scaledSize.getX()), _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().scale(scaledSize.getY())));\n    }\n\n    return this.getCacheKey('CalculatedSize');\n  }\n  /**\n   * Returns the calculated origin point.\n   *\n   * @returns {Vector2f}\n   */\n\n\n  getCalculatedOrigin() {\n    if (!this.hasCacheKey('CalculatedOrigin')) {\n      this.setCacheKey('CalculatedOrigin', new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(_Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().scale(this.getPosition().getX()), _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().scale(this.getPosition().getY())));\n    }\n\n    return this.getCacheKey('CalculatedOrigin');\n  }\n  /**\n   * Returns the offset position.\n   *\n   * @returns {Vector2f}\n   */\n\n\n  getOffsetPosition() {\n    if (!this.hasCacheKey('OffsetPosition')) {\n      this.setCacheKey('OffsetPosition', new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(this.getPosition().getX() + this.getOffset().getX() + this.getAnimation().getFrame().getOffset().getX(), this.getPosition().getY() + this.getOffset().getY() + this.getAnimation().getFrame().getOffset().getY()));\n    }\n\n    return this.getCacheKey('OffsetPosition');\n  }\n  /**\n   * Returns the calculated position for a sprite.\n   *\n   * @returns {Vector2f}\n   */\n\n\n  getCalculatedPosition() {\n    if (!this.hasCacheKey('CalculatedPosition')) {\n      let offsetPosition = this.getOffsetPosition();\n      this.setCacheKey('CalculatedPosition', new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(_Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().scale(offsetPosition.getX()), _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().scale(offsetPosition.getY())));\n    }\n\n    return this.getCacheKey('CalculatedPosition');\n  }\n  /**\n   * Returns the sprite center point, including scaling and offsets.\n   *\n   * @returns {Vector2f}\n   */\n\n\n  getCenter() {\n    if (!this.hasCacheKey('Center')) {\n      let scaledSize = this.getScaledSize();\n      let offsetPosition = this.getOffsetPosition();\n      this.setCacheKey('Center', new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(offsetPosition.getX() + scaledSize.getX() / 2, offsetPosition.getY() + scaledSize.getY() / 2));\n    }\n\n    return this.getCacheKey('Center');\n  }\n  /**\n   * Returns the calculated center point.\n   *\n   * @returns {Vector2f}\n   */\n\n\n  getCalculatedCenter() {\n    if (!this.hasCacheKey('CalculatedCenter')) {\n      let collisionRect = this.getCollisionRect();\n      this.setCacheKey('CalculatedCenter', new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(collisionRect.getX() + collisionRect.getW() / 2, collisionRect.getY() + collisionRect.getH() / 2));\n    }\n\n    return this.getCacheKey('CalculatedCenter');\n  }\n  /**\n   * Returns the appropriate canvas position with horizontal / vertical transformations.\n   *\n   * @returns {null}\n   */\n\n\n  getCanvasPosition() {\n    if (!this.hasCacheKey('CanvasPosition')) {\n      let currentPosition = this.getCalculatedPosition();\n      this.setCacheKey('CanvasPosition', new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(currentPosition.getX() + (this.getFlipX() ? this.getCalculatedSize().getX() : 0), currentPosition.getY() + (this.getFlipY() ? this.getCalculatedSize().getY() : 0)));\n    }\n\n    return this.getCacheKey('CanvasPosition');\n  }\n  /**\n   * Assigns the visibility state.\n   *\n   * @param flag\n   * @returns {Sprite}\n   */\n\n\n  setVisible(flag) {\n    this.visible = flag;\n    return this;\n  }\n  /**\n   * Returns the visibility state.\n   *\n   * @returns {boolean}\n   */\n\n\n  getVisible() {\n    return this.visible;\n  }\n  /**\n   * Indicates whether or not the sprite is on screen.\n   *\n   * @returns {boolean}\n   */\n\n\n  isVisible() {\n    if (!this.hasCacheKey('IsVisible')) {\n      let visibility = this.getVisible();\n\n      if (visibility && this.getPosition().getX() < _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().getScene().getCamera().getPosition().getX() - this.getScaledSize().getX()) {\n        visibility = false;\n      }\n\n      if (visibility && this.getPosition().getY() < _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().getScene().getCamera().getPosition().getY() - this.getScaledSize().getY()) {\n        visibility = false;\n      }\n\n      if (visibility) {\n        let calculatedSize = this.getCalculatedSize();\n        let calculatedPosition = this.getCalculatedPosition();\n        visibility = calculatedPosition.getX() >= -calculatedSize.getX() && calculatedPosition.getX() <= _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().getCanvasWidth() && calculatedPosition.getY() >= -calculatedSize.getY() && calculatedPosition.getY() <= _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().getCanvasHeight();\n      }\n\n      return visibility;\n    }\n\n    return this.getCacheKey('IsVisible');\n  }\n  /**\n   * Indicates whether or not the sprite is in motion.\n   *\n   * @returns {*}\n   */\n\n\n  inMotion() {\n    return this.getAcceleration().getX() || this.getAcceleration().getY();\n  }\n  /**\n   * Returns the calculated distance between two sprites.\n   *\n   * @param sprite\n   * @returns {number}\n   */\n\n\n  getDistanceFrom(sprite) {\n    if (!sprite instanceof Sprite) {\n      return 0;\n    }\n\n    let centerA = this.getCenter();\n    let centerB = sprite.getCenter();\n    return Math.sqrt(Math.pow(centerB.getX() - centerA.getX(), 2) + Math.pow(centerB.getY() - centerA.getY(), 2));\n  }\n  /**\n   * Indicates whether or not the sprite is within a threshold amount to another.\n   *\n   * @param sprite\n   * @param threshold\n   * @returns {boolean}\n   */\n\n\n  isNearby(sprite, threshold) {\n    if (!sprite instanceof Sprite) {\n      return false;\n    }\n\n    threshold = threshold || 100;\n    let centerA = this.getPosition();\n    let centerB = sprite.getPosition();\n    return Math.abs(centerB.getX() - centerA.getX()) < threshold && Math.abs(centerB.getY() - centerA.getY()) < threshold;\n  }\n  /**\n   * Indicates whether or not a sprite is facing another.\n   *\n   * @param sprite\n   * @returns {boolean}\n   */\n\n\n  isFacing(sprite) {\n    if (!sprite instanceof Sprite) {\n      return false;\n    }\n\n    let centerA = this.getCalculatedCenter();\n    let centerB = sprite.getCalculatedCenter();\n\n    switch (this.getDirection()) {\n      case 'Up':\n        return centerB.getY() < centerA.getY();\n\n      case 'Down':\n        return centerB.getY() > centerA.getY();\n\n      case 'Left':\n        return centerB.getX() < centerA.getX();\n\n      case 'Right':\n        return centerB.getX() > centerA.getX();\n    }\n\n    return false;\n  }\n  /**\n   * Returns whether or not the value is in range.\n   *\n   * @param value\n   * @param min\n   * @param max\n   * @param inclusive\n   * @returns {boolean}\n   */\n\n\n  static inRange(value, min, max, inclusive) {\n    if (inclusive) {\n      return value >= min && value <= max;\n    }\n\n    return value > min && value < max;\n  }\n  /**\n   * Returns the collision rectangle.\n   *\n   * @param x\n   * @param y\n   * @returns {Vector4f}\n   */\n\n\n  getCollisionRect(x, y) {\n    x = x ? x : 0;\n    y = y ? y : 0;\n    return this.collisionRect ? new _Math_Vector4f__WEBPACK_IMPORTED_MODULE_2__.Vector4f(this.getPosition().getX() + this.collisionRect.getX() + x, this.getPosition().getY() + this.collisionRect.getY() + y, this.collisionRect.getW() * this.getScale().getX() + x, this.collisionRect.getH() * this.getScale().getY() + y) : new _Math_Vector4f__WEBPACK_IMPORTED_MODULE_2__.Vector4f(this.getPosition().getX() + x, this.getPosition().getY() + y, this.getScaledSize().getX() + x, this.getScaledSize().getY() + y);\n  }\n  /**\n   * Assigns a collision rectangle.\n   *\n   * @param rect\n   * @returns {Sprite}\n   */\n\n\n  setCollisionRect(rect) {\n    if (!rect instanceof _Math_Vector4f__WEBPACK_IMPORTED_MODULE_2__.Vector4f) {\n      return this;\n    }\n\n    this.collisionRect = rect;\n    return this;\n  }\n  /**\n   * Assigns all attributes.\n   *\n   * @param attributes\n   * @returns {Sprite}\n   */\n\n\n  setAttributes(attributes) {\n    if (!attributes instanceof Object) {\n      return this;\n    }\n\n    for (let i in attributes) {\n      if (attributes.hasOwnProperty(i)) {\n        this.setAttribute(i, attributes[i]);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Assigns all events.\n   *\n   * @param events\n   * @returns {Sprite}\n   */\n\n\n  setEvents(events) {\n    if (!events instanceof Object) {\n      return this;\n    }\n\n    for (let i in events) {\n      if (!events.hasOwnProperty(i)) {\n        continue;\n      }\n\n      events[i].map(event => {\n        this.addEvent(i, event);\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Assigns all animations.\n   *\n   * @param animations\n   * @returns {Sprite}\n   */\n\n\n  setAnimations(animations) {\n    if (!animations instanceof Object) {\n      return this;\n    }\n\n    for (let i in animations) {\n      if (animations.hasOwnProperty(i)) {\n        this.addAnimation(i, animations[i]);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Returns the timeline.\n   *\n   * @returns {Timeline}\n   */\n\n\n  getTimeline() {\n    return this.timeline;\n  }\n  /**\n   * Assigns the timeline.\n   *\n   * @param timeline\n   * @returns {Sprite}\n   */\n\n\n  setTimeline(timeline) {\n    if (!timeline instanceof _Animation_Timeline__WEBPACK_IMPORTED_MODULE_3__.Timeline) {\n      return this;\n    }\n\n    this.timeline = timeline;\n    return this;\n  }\n  /**\n   * Returns a new instance.\n   *\n   * @returns {Sprite}\n   */\n\n\n  getInstance() {\n    return new Sprite();\n  }\n  /**\n   * Returns a fresh sprite instance.\n   */\n\n\n  clone() {\n    // Return the cloned instance.\n    return this.getInstance().setAttributes(this.getAttributes()).setEvents(this.getEvents()).setSolid(this.getSolid()).setBehavior(this.getBehavior()).setAnimations(this.getAnimations()).setDirection(this.getDirection()).setMaxAcceleration(this.getMaxAcceleration()).setCollisionRect(this.collisionRect).setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(this.getScale().getX(), this.getScale().getY())).setOffset(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(this.getOffset().getX(), this.getOffset().getY())).setPosition(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(this.getPosition().getX(), this.getPosition().getY())).setAcceleration(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(this.getAcceleration().getX(), this.getAcceleration().getY()));\n  }\n  /**\n   * Method to override collision detection.\n   *\n   * @returns {boolean}\n   */\n\n\n  getCollidable() {\n    return true;\n  }\n  /**\n   * Method to indicate that this entity emits others.\n   *\n   * @returns {boolean}\n   */\n\n\n  hasChildren() {\n    return false;\n  }\n  /**\n   * Indicates whether or not distance events are thrown against a sprite.\n   *\n   * @returns {boolean}\n   */\n\n\n  hasDistanceEvents() {\n    return true;\n  }\n  /**\n   * Renders the sprite based on its animation, and processes any events.\n   */\n\n\n  draw() {\n    if (!this.isVisible()) {\n      return;\n    }\n\n    let currentSize = this.getCalculatedSize();\n    let currentFrame = this.getAnimation().getFrame();\n    let canvasPosition = this.getCanvasPosition(); // Render the current frame.\n\n    this.onRenderBefore(new _Event_RenderBeforePayload__WEBPACK_IMPORTED_MODULE_7__.RenderBeforePayload(this));\n    _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().getContext().globalAlpha = this.getOpacity();\n\n    if (this.isFlipped()) {\n      _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().getContext().save();\n      _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().getContext().translate(canvasPosition.getX(), canvasPosition.getY());\n      canvasPosition = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(0, 0);\n      _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().getContext().scale(this.getFlipX() ? -1 : 1, this.getFlipY() ? -1 : 1);\n    }\n\n    _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().getContext().drawImage(this.getAnimation().getDomResource(), currentFrame.getX(), currentFrame.getY(), Math.round(currentFrame.getW()), Math.round(currentFrame.getH()), Math.round(canvasPosition.getX()), Math.round(canvasPosition.getY()), Math.round(currentSize.getX()), Math.round(currentSize.getY()));\n    _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().getContext().globalAlpha = 1;\n\n    if (this.isFlipped()) {\n      _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().getContext().restore();\n    }\n\n    this.onRenderAfter(); // Update the animation.\n\n    this.getAnimation().update();\n    this.getTimeline().update(); // Apply limiting to the acceleration.\n\n    if (this.getAcceleration().getX() > this.getMaxAcceleration().getX()) {\n      this.getAcceleration().setX(this.getMaxAcceleration().getX());\n    }\n\n    if (this.getAcceleration().getX() < -this.getMaxAcceleration().getX()) {\n      this.getAcceleration().setX(-this.getMaxAcceleration().getX());\n    }\n\n    if (this.getAcceleration().getY() > this.getMaxAcceleration().getY()) {\n      this.getAcceleration().setY(this.getMaxAcceleration().getY());\n    }\n\n    if (this.getAcceleration().getY() < -this.getMaxAcceleration().getY()) {\n      this.getAcceleration().setY(-this.getMaxAcceleration().getY());\n    } // Handle collision and other entity-based events.\n\n\n    let isColliding = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(0, 0);\n    let isCollidable = this.getCollidable();\n\n    if (isCollidable && !this.getSolid() && !this.hasEvents()) {\n      isCollidable = false;\n    }\n\n    if (isCollidable && !this.inMotion()) {\n      isCollidable = false;\n    }\n\n    if (isCollidable) {\n      let neighbors = _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().getScene().getNearbyEntities(this);\n      let entity = null;\n\n      for (let i = 0; i < neighbors.length; i++) {\n        entity = neighbors[i]; // Determine whether or not we should even care about continuing.\n\n        if (!entity instanceof Sprite) {\n          continue;\n        } // Fire off a distance calculation event if the entity is within our defined threshold.\n\n\n        if (entity.hasDistanceEvents()) {\n          this.onDistance(new _Event_DistancePayload__WEBPACK_IMPORTED_MODULE_5__.DistancePayload(this, entity, this.getDistanceFrom(entity)));\n        } // Handle acceleration adjustments.\n\n\n        if (this.inMotion()) {\n          if (this.getCollisionRect(_Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().scale(this.getAcceleration().getX()), 0.00).isColliding(entity.getCollisionRect())) {\n            isColliding.setX(this.getAcceleration().getX() > 0 ? 1 : -1);\n          }\n\n          if (this.getCollisionRect(0.00, _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().scale(this.getAcceleration().getY())).isColliding(entity.getCollisionRect())) {\n            isColliding.setY(this.getAcceleration().getY() > 0 ? 1 : -1);\n          }\n\n          if (Sprite.getFlag('ShowCollisions') && (isColliding.getX() || isColliding.getY())) {\n            _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().getContext().fillStyle = '#000000';\n            _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().getContext().fillRect(this.getCalculatedPosition().getX(), this.getCalculatedPosition().getY(), this.getCalculatedSize().getX(), this.getCalculatedSize().getY());\n            _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().getContext().fillStyle = '#ff0000';\n            _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().getContext().fillRect(entity.getCalculatedPosition().getX(), entity.getCalculatedPosition().getY(), entity.getCalculatedSize().getX(), entity.getCalculatedSize().getY());\n          }\n\n          if (isColliding.getX() || isColliding.getY()) {\n            this.onCollide(new _Event_CollisionPayload__WEBPACK_IMPORTED_MODULE_6__.CollisionPayload(this, entity));\n\n            if (!entity.getSolid()) {\n              isColliding = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(0, 0);\n            }\n          }\n        }\n      }\n    } // Handle deceleration if not moving.\n\n\n    if (this.getAcceleration().getX()) {\n      if (Math.abs(this.getAcceleration().getX()) < 0.01) {\n        this.getAcceleration().setX(0.0);\n      } else {\n        this.getAcceleration().setX(this.getAcceleration().getX() - this.getAcceleration().getX() * 0.1);\n      }\n    }\n\n    if (this.getAcceleration().getY()) {\n      if (Math.abs(this.getAcceleration().getY()) < 0.01) {\n        this.getAcceleration().setY(0.0);\n      } else {\n        this.getAcceleration().setY(this.getAcceleration().getY() - this.getAcceleration().getY() * 0.1);\n      }\n    } // Move position based on acceleration.\n\n\n    if (this.inMotion()) {\n      this.getPosition().add(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(_Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().scale(!isColliding.getX() || isColliding.getX() > 0 && this.getAcceleration().getX() < 0 || isColliding.getX() < 0 && this.getAcceleration().getX() > 0 ? this.getAcceleration().getX() : 0), _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().scale(!isColliding.getY() || isColliding.getY() > 0 && this.getAcceleration().getY() < 0 || isColliding.getY() < 0 && this.getAcceleration().getY() > 0 ? this.getAcceleration().getY() : 0)));\n      this.flushCache();\n    } // Execute the behavior.\n\n\n    this.behave();\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Entity/Sprite.js?");

/***/ }),

/***/ "./src/Entity/Tile.js":
/*!****************************!*\
  !*** ./src/Entity/Tile.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Tile\": () => (/* binding */ Tile)\n/* harmony export */ });\n/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite */ \"./src/Entity/Sprite.js\");\n\nclass Tile extends _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite {\n  /**\n   * Tile constructor.\n   *\n   * @param index\n   * @param position\n   * @param solid\n   */\n  constructor(index, position, solid) {\n    super();\n    this.setIndex(index).setSolid(solid || false).setStatic(true).setPosition(position);\n  }\n  /**\n   * Creates a new tile index.\n   *\n   * @param index\n   * @param position\n   * @param solid\n   * @returns {Tile}\n   */\n\n\n  static create(index, position, solid) {\n    return new Tile(index, position, solid);\n  }\n  /**\n   * Assigns the index.\n   *\n   * @param index\n   * @returns {this}\n   */\n\n\n  setIndex(index) {\n    this.index = index;\n    return this;\n  }\n  /**\n   * Returns the index.\n   *\n   * @returns {number}\n   */\n\n\n  getIndex() {\n    return this.index;\n  }\n  /**\n   * Tiles should not throw distance events as an optimization step.\n   *\n   * @returns {boolean}\n   */\n\n\n  hasDistanceEvents() {\n    return false;\n  }\n  /**\n   * Prevent collision detection among tiles.\n   *\n   * @returns {boolean}\n   */\n\n\n  getCollidable() {\n    return false;\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Entity/Tile.js?");

/***/ }),

/***/ "./src/Event/CollisionPayload.js":
/*!***************************************!*\
  !*** ./src/Event/CollisionPayload.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CollisionPayload\": () => (/* binding */ CollisionPayload)\n/* harmony export */ });\n/* harmony import */ var _EventPayload__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventPayload */ \"./src/Event/EventPayload.js\");\n\nclass CollisionPayload extends _EventPayload__WEBPACK_IMPORTED_MODULE_0__.EventPayload {\n  /**\n   * CollisionPayload constructor.\n   *\n   * @param root\n   * @param entity\n   */\n  constructor(root, entity) {\n    super();\n    this.root = root;\n    this.entity = entity;\n  }\n  /**\n   * Returns the event root.\n   *\n   * @returns Sprite\n   */\n\n\n  getRoot() {\n    return this.root;\n  }\n  /**\n   * Returns the event initiator.\n   *\n   * @returns Sprite\n   */\n\n\n  getEntity() {\n    return this.entity;\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Event/CollisionPayload.js?");

/***/ }),

/***/ "./src/Event/DistancePayload.js":
/*!**************************************!*\
  !*** ./src/Event/DistancePayload.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DistancePayload\": () => (/* binding */ DistancePayload)\n/* harmony export */ });\n/* harmony import */ var _EventPayload__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventPayload */ \"./src/Event/EventPayload.js\");\n\nclass DistancePayload extends _EventPayload__WEBPACK_IMPORTED_MODULE_0__.EventPayload {\n  /**\n   * DistancePayload constructor.\n   *\n   * @param root\n   * @param entity\n   * @param distance\n   */\n  constructor(root, entity, distance) {\n    super();\n    this.root = root;\n    this.entity = entity;\n    this.distance = distance;\n  }\n  /**\n   * Returns the root entity.\n   *\n   * @returns {Sprite}\n   */\n\n\n  getRoot() {\n    return this.root;\n  }\n  /**\n   * Returns the linked sprite.\n   *\n   * @returns Sprite\n   */\n\n\n  getEntity() {\n    return this.entity;\n  }\n  /**\n   * Returns the distance value.\n   *\n   * @returns {*}\n   */\n\n\n  getDistance() {\n    return this.distance;\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Event/DistancePayload.js?");

/***/ }),

/***/ "./src/Event/EventPayload.js":
/*!***********************************!*\
  !*** ./src/Event/EventPayload.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EventPayload\": () => (/* binding */ EventPayload)\n/* harmony export */ });\nclass EventPayload {\n  /**\n   * EventPayload constructor.\n   */\n  constructor() {}\n\n}\n\n//# sourceURL=webpack://charset/./src/Event/EventPayload.js?");

/***/ }),

/***/ "./src/Event/RenderBeforePayload.js":
/*!******************************************!*\
  !*** ./src/Event/RenderBeforePayload.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RenderBeforePayload\": () => (/* binding */ RenderBeforePayload)\n/* harmony export */ });\n/* harmony import */ var _EventPayload__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventPayload */ \"./src/Event/EventPayload.js\");\n\nclass RenderBeforePayload extends _EventPayload__WEBPACK_IMPORTED_MODULE_0__.EventPayload {\n  /**\n   * RenderBeforePayload constructor.\n   *\n   * @param sprite\n   */\n  constructor(sprite) {\n    super();\n    this.sprite = sprite;\n  }\n  /**\n   * Returns the event initiator.\n   *\n   * @returns Sprite\n   */\n\n\n  getSprite() {\n    return this.sprite;\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Event/RenderBeforePayload.js?");

/***/ }),

/***/ "./src/Example/Procedural/Entity/ISprite.js":
/*!**************************************************!*\
  !*** ./src/Example/Procedural/Entity/ISprite.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ISprite\": () => (/* binding */ ISprite)\n/* harmony export */ });\n/* harmony import */ var _Kernel_State__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Kernel/State */ \"./src/Kernel/State.js\");\n/* harmony import */ var _Graphic_Frame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Graphic/Frame */ \"./src/Graphic/Frame.js\");\n/* harmony import */ var _Entity_Sprite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../Entity/Sprite */ \"./src/Entity/Sprite.js\");\n/* harmony import */ var _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../Kernel/Engine */ \"./src/Kernel/Engine.js\");\n/* harmony import */ var _Entity_Emitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../Entity/Emitter */ \"./src/Entity/Emitter.js\");\n/* harmony import */ var _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../Math/Vector2f */ \"./src/Math/Vector2f.js\");\n/* harmony import */ var _Graphic_Particle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../Graphic/Particle */ \"./src/Graphic/Particle.js\");\n/* harmony import */ var _Animation_Timeline__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../Animation/Timeline */ \"./src/Animation/Timeline.js\");\n/* harmony import */ var _Animation_Sequence__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../Animation/Sequence */ \"./src/Animation/Sequence.js\");\n/* harmony import */ var _Animation_KeyFrame__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../Animation/KeyFrame */ \"./src/Animation/KeyFrame.js\");\n\n\n\n\n\n\n\n\n\n\nclass ISprite extends _Entity_Sprite__WEBPACK_IMPORTED_MODULE_2__.Sprite {\n  /**\n   * The sprite constructor.\n   *\n   * @param src\n   * @param frame\n   */\n  constructor(src, frame) {\n    super(src, frame);\n    this.setZIndex(5).addEvent('Distance', ISprite.handleZShift).addEvent('RenderAfter', ISprite.addShadowAfter).addEvent('RenderBefore', ISprite.addShadowBefore).addEvent('UpdateHealth', ISprite.handleHealthUpdate).addLinkedSprites();\n  }\n  /**\n   * Returns a new ISprite instance.\n   *\n   * @param src\n   * @param frame\n   * @returns {ISprite}\n   */\n\n\n  static create(src, frame) {\n    return new ISprite(src, frame);\n  }\n  /**\n   * Returns a new instance.\n   *\n   * @returns {ISprite}\n   */\n\n\n  getInstance() {\n    return new ISprite();\n  }\n  /**\n   * Registers all linked sprites.\n   *\n   * @returns this\n   */\n\n\n  addLinkedSprites() {\n    const engine = _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine();\n    const scene = engine.getScene(); // Assign a HP frame if one isn't already linked.\n\n    if (!this.getAttribute('Linked/GUI/HealthFrame')) {\n      this.setAttribute('Linked/GUI/HealthFrame', _Entity_Sprite__WEBPACK_IMPORTED_MODULE_2__.Sprite.create('resources/pack_rpg_ui/bars/bar_56.png').setOpacity(0).setPosition(this.getPosition()).setBehavior(self => {\n        self.setPosition(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f(this.getPosition().getX() + this.getScaledSize().getX() / 2 - self.getScaledSize().getX() / 2, this.getPosition().getY()));\n      }));\n      scene.addEntity(ISprite.getUniqueName('GUI/HealthFrame'), this.getAttribute('Linked/GUI/HealthFrame'));\n    } // Assign a HP bar if one isn't already linked.\n\n\n    if (!this.getAttribute('Linked/GUI/HealthBar')) {\n      this.setAttribute('Linked/GUI/HealthBar', _Entity_Sprite__WEBPACK_IMPORTED_MODULE_2__.Sprite.create('resources/pack_rpg_ui/bars/bar_76.png', _Graphic_Frame__WEBPACK_IMPORTED_MODULE_1__.Frame.create(2, 3, 20, 2)).setOpacity(0).setPosition(this.getPosition()).setBehavior(self => {\n        self.setPosition(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f(this.getAttribute('Linked/GUI/HealthFrame').getPosition().getX() + 2, this.getAttribute('Linked/GUI/HealthFrame').getPosition().getY() + 3)).setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f(this.getAttribute('Health') / this.getAttribute('MaxHealth'), 1));\n      }));\n      scene.addEntity(ISprite.getUniqueName('GUI/HealthBar'), this.getAttribute('Linked/GUI/HealthBar'));\n    } // Link a new particle emitter.\n\n\n    if (!this.getAttribute('Linked/Emitter/Effects')) {\n      this.setAttribute('Linked/Emitter/Effects', _Entity_Emitter__WEBPACK_IMPORTED_MODULE_4__.Emitter.create(self => {\n        const scale = Math.random() * 2;\n        const entity = self.getAttribute('Linked/Entity');\n        const cloned = _Entity_Sprite__WEBPACK_IMPORTED_MODULE_2__.Sprite.create().addEvent('RenderBefore', payload => {\n          const sprite = payload.getSprite();\n          const engine = _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine(); // Render the particle onto the canvas.\n\n          _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.rectangle(sprite.getCalculatedPosition(), new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f(engine.scale(sprite.getScale().getX()), engine.scale(sprite.getScale().getY())), sprite.getAttribute('Color'), sprite.getOpacity());\n        });\n\n        switch (self.getAttribute('Variant')) {\n          case 'LevelUp':\n            cloned.setVisible(true).setAttribute('Color', '#ffdf54').setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f(scale, scale)).setOpacity(1).getPosition().setX(entity.getPosition().getX() + entity.getScaledSize().getX() / 2).setY(entity.getPosition().getY() + entity.getScaledSize().getY());\n            cloned.setTimeline(_Animation_Timeline__WEBPACK_IMPORTED_MODULE_7__.Timeline.create([_Animation_Sequence__WEBPACK_IMPORTED_MODULE_8__.Sequence.create(value => {\n              let output = Math.sin(value * Math.PI / 180.0);\n              cloned.setZIndex(entity.getZIndex() + (output < 0 ? -1 : 1)).getAcceleration().setX(output);\n            }).addKeyFrame(new _Animation_KeyFrame__WEBPACK_IMPORTED_MODULE_9__.KeyFrame(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f(90, 720 + Math.random() * 360), 2)), _Animation_Sequence__WEBPACK_IMPORTED_MODULE_8__.Sequence.create(value => cloned.getAcceleration().setY(-value)).addKeyFrame(new _Animation_KeyFrame__WEBPACK_IMPORTED_MODULE_9__.KeyFrame(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f(0, 0.4), 2)), _Animation_Sequence__WEBPACK_IMPORTED_MODULE_8__.Sequence.create(value => cloned.setOpacity(value)).addKeyFrame(new _Animation_KeyFrame__WEBPACK_IMPORTED_MODULE_9__.KeyFrame(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f(1, 1), 1)).addKeyFrame(new _Animation_KeyFrame__WEBPACK_IMPORTED_MODULE_9__.KeyFrame(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f(1, 0), 1))]));\n            break;\n\n          default:\n            cloned.setVisible(true).setAttribute('Color', '#ff0000').setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f(scale, scale)).setOpacity(0).setZIndex(entity.getZIndex() - 1).getPosition().setX(entity.getPosition().getX() + (Math.random() - 0.5) * 12 + entity.getScaledSize().getX() / 2).setY(entity.getPosition().getY() + (Math.random() - 0.5) * 12 + entity.getScaledSize().getY() / 4);\n            cloned.getAcceleration().setY(-Math.random() / 4);\n            cloned.setTimeline(_Animation_Timeline__WEBPACK_IMPORTED_MODULE_7__.Timeline.create([_Animation_Sequence__WEBPACK_IMPORTED_MODULE_8__.Sequence.create(value => cloned.getAcceleration().add(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f(value, 0))).addKeyFrame(new _Animation_KeyFrame__WEBPACK_IMPORTED_MODULE_9__.KeyFrame(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f((Math.random() - 0.5) / 8, 0), 0.6)), _Animation_Sequence__WEBPACK_IMPORTED_MODULE_8__.Sequence.create(value => cloned.getAcceleration().add(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f(0, value))).addKeyFrame(new _Animation_KeyFrame__WEBPACK_IMPORTED_MODULE_9__.KeyFrame(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f(0, Math.random() / 6), 1)), _Animation_Sequence__WEBPACK_IMPORTED_MODULE_8__.Sequence.create(value => cloned.setOpacity(value)).addKeyFrame(new _Animation_KeyFrame__WEBPACK_IMPORTED_MODULE_9__.KeyFrame(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f(1, 1), 0.5)).addKeyFrame(new _Animation_KeyFrame__WEBPACK_IMPORTED_MODULE_9__.KeyFrame(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f(1, 0), 0.5))]));\n            break;\n        }\n\n        return new _Graphic_Particle__WEBPACK_IMPORTED_MODULE_6__.Particle(cloned, cloned.getTimeline().getDurationInMilliseconds());\n      }, 10, 50));\n      scene.addEntity(ISprite.getUniqueName('Emitter/Effects'), this.getAttribute('Linked/Emitter/Effects'));\n    } // Link a separate damage emitter.\n\n\n    if (!this.getAttribute('Linked/Emitter/Counter')) {\n      this.setAttribute('Linked/Emitter/Counter', _Entity_Emitter__WEBPACK_IMPORTED_MODULE_4__.Emitter.create(self => {\n        const scale = Math.random() * 3;\n        const entity = self.getAttribute('Linked/Entity');\n        const cloned = _Entity_Sprite__WEBPACK_IMPORTED_MODULE_2__.Sprite.create().addEvent('RenderBefore', payload => {\n          const entity = payload.getSprite(); // Display the text damage value.\n\n          _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().text(entity.getAttribute('DamageValue'), entity.getCalculatedPosition(), 12, entity.getAttribute('Color'), entity.getOpacity());\n        });\n        cloned.setVisible(true).setOpacity(0).setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f(scale, scale)).setAttribute('Color', self.getAttribute('DamageValue') > 0 ? '#ffffff' : '#04ff57').setAttribute('DamageValue', `${self.getAttribute('DamageValue') > 0 ? `-` : `+`}${self.getAttribute('DamageValue')}`).getPosition().setX(entity.getPosition().getX() + (Math.random() - 0.5) * 12 + entity.getScaledSize().getX() / 2).setY(entity.getPosition().getY() + (Math.random() - 0.5) * 12 + entity.getScaledSize().getY() / 4);\n        cloned.getAcceleration().setY(-Math.random() - 0.5);\n        cloned.setTimeline(_Animation_Timeline__WEBPACK_IMPORTED_MODULE_7__.Timeline.create([_Animation_Sequence__WEBPACK_IMPORTED_MODULE_8__.Sequence.create(value => cloned.getAcceleration().add(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f(value, 0))).addKeyFrame(new _Animation_KeyFrame__WEBPACK_IMPORTED_MODULE_9__.KeyFrame(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f((Math.random() - 0.5) / 10, 0), 2)), _Animation_Sequence__WEBPACK_IMPORTED_MODULE_8__.Sequence.create(value => cloned.getAcceleration().add(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f(0, value))).addKeyFrame(new _Animation_KeyFrame__WEBPACK_IMPORTED_MODULE_9__.KeyFrame(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f(0, Math.random() / 6), 2)), _Animation_Sequence__WEBPACK_IMPORTED_MODULE_8__.Sequence.create(value => cloned.setOpacity(value)).addKeyFrame(new _Animation_KeyFrame__WEBPACK_IMPORTED_MODULE_9__.KeyFrame(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f(1, 0), 2))]));\n        return new _Graphic_Particle__WEBPACK_IMPORTED_MODULE_6__.Particle(cloned, cloned.getTimeline().getDurationInMilliseconds());\n      }, 2, 1));\n      scene.addEntity(ISprite.getUniqueName('Emitter/Counter'), this.getAttribute('Linked/Emitter/Counter'));\n    }\n\n    return this;\n  }\n  /**\n   * Handles the drawing priority shift whenever sprites move around one another.\n   *\n   * @param payload\n   */\n\n\n  static handleZShift(payload) {\n    const self = payload.getRoot();\n    const entity = payload.getEntity();\n    const beneath = self.getOffsetPosition().getY() + self.getScaledSize().getY() > entity.getOffsetPosition().getY() + entity.getScaledSize().getY();\n    self.setZIndex(entity.getZIndex() + (beneath ? 1 : -1));\n  }\n  /**\n   * Handles the damage effect.\n   *\n   * @param payload\n   */\n\n\n  static handleHealthUpdate(payload) {\n    const root = payload.getRoot();\n    const engine = _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine();\n    const entity = payload.getEntity(); // Reduce the health counter by the payload damage.\n\n    entity.setAttribute('Health', entity.getAttribute('Health') - payload.getDamage()); // Handle death.\n\n    if (entity.getAttribute('Health') <= 0) {\n      entity.setAttribute('Health', 0).setSolid(false);\n\n      if (entity.hasAnimation('Death')) {\n        entity.setAnimation('Death');\n      }\n    } // Emit blood from the entity.\n\n\n    entity.getAttribute('Linked/Emitter/Effects').setAttribute('Linked/Entity', entity).setAttribute('Variant', 'Damage').setTimeline(_Animation_Timeline__WEBPACK_IMPORTED_MODULE_7__.Timeline.create([_Animation_Sequence__WEBPACK_IMPORTED_MODULE_8__.Sequence.create(value => {\n      if (!value) {\n        entity.getAttribute('Linked/Emitter/Effects').stop();\n      }\n    }).addKeyFrame(new _Animation_KeyFrame__WEBPACK_IMPORTED_MODULE_9__.KeyFrame(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f(1, 0), 2))])).play(); // Throw the damage amount.\n\n    entity.getAttribute('Linked/Emitter/Counter').setAttribute('Linked/Entity', entity).setAttribute('DamageValue', payload.getDamage()).addParticle(); // Push the entity back.\n\n    entity.getAcceleration().add(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f((entity.getCenter().getX() - root.getCenter().getX()) * 0.1, (entity.getCenter().getY() - root.getCenter().getY()) * 0.1));\n\n    if (!engine.getScene().getCamera().getShake()) {\n      engine.getScene().getCamera().setTimeline(_Animation_Timeline__WEBPACK_IMPORTED_MODULE_7__.Timeline.create([_Animation_Sequence__WEBPACK_IMPORTED_MODULE_8__.Sequence.create(value => engine.getScene().getCamera().setShake(value)).addKeyFrame(_Animation_KeyFrame__WEBPACK_IMPORTED_MODULE_9__.KeyFrame.create(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_5__.Vector2f(4, 0), 0.3))]));\n    }\n  }\n  /**\n   * Casts a shadow to an entity.\n   *\n   * @param payload\n   */\n\n\n  static addShadowBefore(payload) {\n    const context = _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().getContext();\n    context.shadowOffsetX = 0;\n    context.shadowOffsetY = _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().scale(1);\n    context.shadowColor = 'rgba(0,0,0,0.2)';\n    context.shadowBlur = _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().scale(1);\n  }\n  /**\n   * Casts a shadow to an entity.\n   *\n   * @param payload\n   */\n\n\n  static addShadowAfter(payload) {\n    const context = _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().getContext();\n    context.shadowOffsetX = 0;\n    context.shadowOffsetY = 0;\n    context.shadowColor = 'black';\n    context.shadowBlur = 0;\n  }\n  /**\n   * Returns a unique name.\n   *\n   * @param prefix\n   * @returns {string}\n   */\n\n\n  static getUniqueName(prefix) {\n    return (prefix ? `${prefix}/` : '') + Math.random().toString(36).substring(7);\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Example/Procedural/Entity/ISprite.js?");

/***/ }),

/***/ "./src/Example/Procedural/Event/UpdateHealthPayload.js":
/*!*************************************************************!*\
  !*** ./src/Example/Procedural/Event/UpdateHealthPayload.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UpdateHealthPayload\": () => (/* binding */ UpdateHealthPayload)\n/* harmony export */ });\n/* harmony import */ var _Event_EventPayload__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Event/EventPayload */ \"./src/Event/EventPayload.js\");\n\nclass UpdateHealthPayload extends _Event_EventPayload__WEBPACK_IMPORTED_MODULE_0__.EventPayload {\n  /**\n   * EventPayload constructor.\n   *\n   * @param root\n   * @param entity\n   * @param damage\n   */\n  constructor(root, entity, damage) {\n    super();\n    this.root = root;\n    this.entity = entity;\n    this.damage = damage;\n  }\n  /**\n   * Returns the root entity.\n   *\n   * @returns {Sprite}\n   */\n\n\n  getRoot() {\n    return this.root;\n  }\n  /**\n   * Returns the entity.\n   *\n   * @returns {Sprite}\n   */\n\n\n  getEntity() {\n    return this.entity;\n  }\n  /**\n   * Returns the damage.\n   *\n   * @returns {number}\n   */\n\n\n  getDamage() {\n    return this.damage;\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Example/Procedural/Event/UpdateHealthPayload.js?");

/***/ }),

/***/ "./src/Example/Procedural/Game.js":
/*!****************************************!*\
  !*** ./src/Example/Procedural/Game.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Game\": () => (/* binding */ Game)\n/* harmony export */ });\n/* harmony import */ var _Generation_Path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Generation/Path */ \"./src/Example/Procedural/Generation/Path.js\");\n/* harmony import */ var _Graphic_Frame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Graphic/Frame */ \"./src/Graphic/Frame.js\");\n/* harmony import */ var _Scene_Camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Scene/Camera */ \"./src/Scene/Camera.js\");\n/* harmony import */ var _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Kernel/Engine */ \"./src/Kernel/Engine.js\");\n/* harmony import */ var _Entity_Sprite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Entity/Sprite */ \"./src/Entity/Sprite.js\");\n/* harmony import */ var _Entity_ISprite__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Entity/ISprite */ \"./src/Example/Procedural/Entity/ISprite.js\");\n/* harmony import */ var _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../Math/Vector2f */ \"./src/Math/Vector2f.js\");\n/* harmony import */ var _Math_Vector4f__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../Math/Vector4f */ \"./src/Math/Vector4f.js\");\n/* harmony import */ var _Animation_KeyFrame__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../Animation/KeyFrame */ \"./src/Animation/KeyFrame.js\");\n/* harmony import */ var _Animation_Sequence__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../Animation/Sequence */ \"./src/Animation/Sequence.js\");\n/* harmony import */ var _Animation_Timeline__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../Animation/Timeline */ \"./src/Animation/Timeline.js\");\n/* harmony import */ var _Generation_Generator__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Generation/Generator */ \"./src/Example/Procedural/Generation/Generator.js\");\n/* harmony import */ var _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../Animation/Animation */ \"./src/Animation/Animation.js\");\n/* harmony import */ var _Event_UpdateHealthPayload__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Event/UpdateHealthPayload */ \"./src/Example/Procedural/Event/UpdateHealthPayload.js\");\n/* harmony import */ var _Math_Matrix__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../Math/Matrix */ \"./src/Math/Matrix.js\");\n/* harmony import */ var _Scene_Scene__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../Scene/Scene */ \"./src/Scene/Scene.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Game extends _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine {\n  static sceneNodes = _Math_Matrix__WEBPACK_IMPORTED_MODULE_14__.Matrix.create(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(50, 50));\n  static scenePosition = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(25, 25);\n  /**\n   * Game constructor.\n   */\n\n  constructor() {\n    super();\n  }\n  /**\n   * Draws a GUI window to the screen\n   *\n   * @param rect\n   */\n\n\n  static getGUIFrame(rect) {\n    if (!rect instanceof _Math_Vector4f__WEBPACK_IMPORTED_MODULE_7__.Vector4f) {\n      return;\n    }\n\n    let scale = 2;\n    _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/TopLeft').setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(scale, scale)).setPosition(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(rect.getX(), rect.getY()));\n    rect.setW(rect.getW() - _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/TopLeft').getScaledSize().getX());\n    rect.setH(rect.getH() - _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/TopLeft').getScaledSize().getY());\n    _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/TopRight').setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(scale, scale)).setPosition(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(rect.getX() + rect.getW(), rect.getY()));\n    _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/BottomRight').setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(scale, scale)).setPosition(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(rect.getX() + rect.getW(), rect.getY() + rect.getH()));\n    _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/BottomLeft').setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(scale, scale)).setPosition(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(rect.getX(), rect.getY() + rect.getH()));\n    let left = _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/Left').clone().setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(scale, scale)).setPosition(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(rect.getX(), rect.getY() + _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/TopLeft').getScaledSize().getY())).setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(scale, rect.getH() / _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/Left').getScaledSize().getY() - scale));\n    let right = _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/Right').clone().setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(scale, scale)).setPosition(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(rect.getX() + rect.getW(), rect.getY() + _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/TopLeft').getScaledSize().getY())).setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(scale, rect.getH() / _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/Right').getScaledSize().getY() - scale));\n    let bottom = _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/Bottom').clone().setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(scale, scale)).setPosition(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(rect.getX() + _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/TopLeft').getScaledSize().getX(), rect.getY() + rect.getH())).setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(rect.getW() / _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/Bottom').getScaledSize().getX() - scale, scale));\n    let top = _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/Top').clone().setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(scale, scale)).setPosition(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(rect.getX() + _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/TopLeft').getScaledSize().getX(), rect.getY())).setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(rect.getW() / _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/Top').getScaledSize().getX() - scale, scale));\n    let center = _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/Center').clone().setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(scale, scale)).setPosition(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(rect.getX() + _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/TopLeft').getScaledSize().getX(), rect.getY() + _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/TopLeft').getScaledSize().getY())).setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(rect.getW() / _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/Center').getScaledSize().getX() - scale, rect.getH() / _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/Center').getScaledSize().getY() - scale));\n    Game.drawSprite(_Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/TopLeft'));\n    Game.drawSprite(_Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/TopRight'));\n    Game.drawSprite(_Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/BottomRight'));\n    Game.drawSprite(_Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/BottomLeft'));\n    Game.drawSprite(top);\n    Game.drawSprite(left);\n    Game.drawSprite(right);\n    Game.drawSprite(bottom);\n    Game.drawSprite(center);\n  }\n  /**\n   * Returns the player instance.\n   *\n   * @returns {Sprite}\n   */\n\n\n  static getPlayer() {\n    let engine = _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getInstance();\n    return _Entity_ISprite__WEBPACK_IMPORTED_MODULE_5__.ISprite.create().setSolid(true).setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(1.5, 1.5)).setPosition(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(250, 250)).setCollisionRect(new _Math_Vector4f__WEBPACK_IMPORTED_MODULE_7__.Vector4f(0, 10, 9, 10)).addEvent('Distance', payload => {\n      let self = payload.getRoot();\n      let entity = payload.getEntity();\n      let distance = payload.getDistance(); // Display the health bar.\n\n      let bar = entity.getAttribute('Linked/GUI/HealthBar');\n      let frame = entity.getAttribute('Linked/GUI/HealthFrame');\n\n      if (!bar || !frame) {\n        return;\n      }\n\n      bar.setTimeline(_Animation_Timeline__WEBPACK_IMPORTED_MODULE_10__.Timeline.create([_Animation_Sequence__WEBPACK_IMPORTED_MODULE_9__.Sequence.create(value => {\n        bar.setOpacity(value);\n      }).addKeyFrame(new _Animation_KeyFrame__WEBPACK_IMPORTED_MODULE_8__.KeyFrame(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(entity.isAlive() ? 1 : 0, 0), 0.5))]));\n      frame.setTimeline(_Animation_Timeline__WEBPACK_IMPORTED_MODULE_10__.Timeline.create([_Animation_Sequence__WEBPACK_IMPORTED_MODULE_9__.Sequence.create(value => {\n        frame.setOpacity(value);\n      }).addKeyFrame(new _Animation_KeyFrame__WEBPACK_IMPORTED_MODULE_8__.KeyFrame(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(entity.isAlive() ? 1 : 0, 0), 0.5))])); // Remove the health bar for entities that aren't alive.\n\n      if (!entity.isAlive()) {\n        return;\n      } // Handle attacks if the entity is in range.\n\n\n      if (distance < 40 && engine.getController().getState('LeftShift')) {\n        entity.callEvents('UpdateHealth', new _Event_UpdateHealthPayload__WEBPACK_IMPORTED_MODULE_13__.UpdateHealthPayload(self, entity, 10 + Math.floor(Math.random() * 10)));\n      }\n    }).addAnimation('Default', _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__.Animation.create('resources/pack_rpg_character/Static/c3.png').addFrame(_Graphic_Frame__WEBPACK_IMPORTED_MODULE_1__.Frame.create(19, 13, 9, 20))).setBehavior(self => {\n      if (self.getAcceleration().getX()) {\n        self.setFlipX(self.getAcceleration().getX() < 0);\n      }\n\n      if (engine.getController().getState('1Key')) {\n        self.setAttribute('Health', self.getAttribute('MaxHealth'));\n        self.getAttribute('Linked/Emitter/Effects').setAttribute('Linked/Entity', self).setAttribute('Variant', 'LevelUp').setTimeline(_Animation_Timeline__WEBPACK_IMPORTED_MODULE_10__.Timeline.create([_Animation_Sequence__WEBPACK_IMPORTED_MODULE_9__.Sequence.create(value => {\n          if (!value) {\n            self.getAttribute('Linked/Emitter/Effects').stop();\n          }\n        }).addKeyFrame(new _Animation_KeyFrame__WEBPACK_IMPORTED_MODULE_8__.KeyFrame(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(1, 0), 2))])).play();\n      }\n\n      if (self.getAttribute('Health') > 0) {\n        if (self.getAnimation().getLoop() || !self.getAnimation().isPlaying) {\n          // Display the attack animation.\n          if (!engine.getController().getState('LeftShift')) {\n            // If not moving and not attacking, display the first directional frame.\n            if (!engine.getController().hasArrowKeyDown()) {\n              switch (self.getDirection()) {\n                case 'Down':\n                  self.setAnimation('Default').getAnimation().setFrame(0).stop();\n                  break;\n\n                case 'Right':\n                  self.setAnimation('Default').getAnimation().setFrame(0).stop();\n                  break;\n\n                case 'Up':\n                  self.setAnimation('Default').getAnimation().setFrame(0).stop();\n                  break;\n\n                case 'Left':\n                  self.setAnimation('Default').getAnimation().setFrame(0).stop();\n                  break;\n              }\n            } // Handle character movement.\n\n\n            if (engine.getController().getState('UpArrow')) {\n              engine.getScene().getEntity('Player').setDirection('Up').getAcceleration().add(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(0, -0.1));\n            }\n\n            if (engine.getController().getState('DownArrow')) {\n              engine.getScene().getEntity('Player').setDirection('Down').getAcceleration().add(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(0, 0.1));\n            }\n\n            if (engine.getController().getState('LeftArrow')) {\n              engine.getScene().getEntity('Player').setDirection('Left').getAcceleration().add(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(-0.1, 0));\n            }\n\n            if (engine.getController().getState('RightArrow')) {\n              engine.getScene().getEntity('Player').setDirection('Right').getAcceleration().add(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(0.1, 0));\n            }\n          }\n        }\n      } // Force player to stay in bounds.\n\n\n      let transition = false;\n      let momentum = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(0, 0);\n\n      if (self.getPosition().getX() < 0) {\n        self.setAttribute('Scene/LastPosition', new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(self.getPosition().getX(), self.getPosition().getY()));\n        self.getPosition().setX(engine.getScene().getArea().getX() - self.getScaledSize().getX());\n        transition = true;\n        momentum.setX(-1);\n      }\n\n      if (self.getPosition().getY() < 0) {\n        self.setAttribute('Scene/LastPosition', new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(self.getPosition().getX(), self.getPosition().getY()));\n        self.getPosition().setY(engine.getScene().getArea().getY() - self.getScaledSize().getY());\n        transition = true;\n        momentum.setY(-1);\n      }\n\n      if (self.getPosition().getX() > engine.getScene().getArea().getX() - self.getScaledSize().getX()) {\n        self.setAttribute('Scene/LastPosition', new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(self.getPosition().getX(), self.getPosition().getY()));\n        self.getPosition().setX(0);\n        transition = true;\n        momentum.setX(1);\n      }\n\n      if (self.getPosition().getY() > engine.getScene().getArea().getY() - self.getScaledSize().getY()) {\n        self.setAttribute('Scene/LastPosition', new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(self.getPosition().getX(), self.getPosition().getY()));\n        self.getPosition().setY(0);\n        transition = true;\n        momentum.setY(1);\n      }\n\n      if (transition) {\n        self.setAttribute('Scene/LastScene', new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(Game.scenePosition.getX(), Game.scenePosition.getY()));\n        Game.scenePosition.add(momentum);\n\n        if (Game.sceneNodes.getValue(Game.scenePosition) instanceof _Scene_Scene__WEBPACK_IMPORTED_MODULE_15__.Scene) {\n          engine.setScene(Game.sceneNodes.getValue(Game.scenePosition));\n        } else {\n          const generator = new _Generation_Generator__WEBPACK_IMPORTED_MODULE_11__.Generator(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(50, 50), 'resources/pack_som/tiles_1.png', new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(30, 16));\n          generator.addPath(new _Generation_Path__WEBPACK_IMPORTED_MODULE_0__.Path(generator.getArea()));\n          let scene = generator.getScene();\n          scene.setSprites(engine.getScene().getSprites()).addCamera('Default', _Scene_Camera__WEBPACK_IMPORTED_MODULE_2__.Camera.create().setSprite(_Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('Player')).setZoom(2));\n          engine.setScene(scene);\n          Game.sceneNodes.setValue(Game.scenePosition, engine.getScene());\n        }\n      }\n    });\n  }\n  /**\n   * Initialize the game resources.\n   */\n\n\n  getSetup() {\n    const engine = _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getInstance();\n    const generator = new _Generation_Generator__WEBPACK_IMPORTED_MODULE_11__.Generator(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(50, 50), 'resources/pack_som/tiles_1.png', new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(30, 16));\n    this.setScene(generator.getScene());\n    let playerStart = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(Math.floor(Math.random() * 49) * 16, Math.floor(Math.random() * 48) * 16);\n    this.getScene().addEntity('Player', Game.getPlayer); // .addEntity('Boss/Ghoul', () => {\n    //     return ISprite.create()\n    //         .setSolid(true)\n    //         .setScale(new Vector2f(1.6, 1.6))\n    //         .setPosition(new Vector2f(50, 50))\n    //         .addAnimation('Idle',\n    //             Animation.create('resources/enemy_ghoul/ghoul-Sheet.png')\n    //                 .setRate(6)\n    //                 .addFrame(Frame.create(0, 1, 51, 18))\n    //                 .addFrame(Frame.create(51, 1, 51, 18))\n    //                 .addFrame(Frame.create(102, 1, 51, 18))\n    //                 .addFrame(Frame.create(153, 1, 51, 18))\n    //                 .play()\n    //         );\n    // })\n    // .addEntity('Boss/Golem', () => {\n    //     return ISprite.create()\n    //         .setSolid(true)\n    //         .setScale(new Vector2f(1.8, 1.8))\n    //         .setPosition(new Vector2f(100, 50))\n    //         .setCollisionRect(new Vector4f(19, 16, 47, 40))\n    //         .addAnimation('Idle',\n    //             Animation.create('resources/enemy_golem/golem-Sheet.png')\n    //                 .setRate(4)\n    //                 .addFrame(Frame.create(0, 0, 74, 57))\n    //                 .addFrame(Frame.create(74, 0, 74, 57))\n    //                 .addFrame(Frame.create(148, 0, 74, 57))\n    //                 .addFrame(Frame.create(222, 0, 74, 57))\n    //                 .addFrame(Frame.create(296, 0, 74, 57))\n    //                 .play()\n    //         )\n    //         .addAnimation('Death',\n    //             Animation.create('resources/enemy_golem/golem-Sheet.png')\n    //                 .setRate(4)\n    //                 .setLoop(false)\n    //                 .addFrame(Frame.create(148, 284, 74, 57))\n    //                 .addFrame(Frame.create(222, 284, 74, 57))\n    //                 .addFrame(Frame.create(296, 284, 74, 57))\n    //                 .addFrame(Frame.create(370, 284, 74, 57))\n    //                 .addFrame(Frame.create(0, 341, 74, 57))\n    //                 .addFrame(Frame.create(74, 341, 74, 57))\n    //                 .addFrame(Frame.create(148, 341, 74, 57))\n    //                 .addFrame(Frame.create(222, 341, 74, 57))\n    //                 .addFrame(Frame.create(296, 341, 74, 57))\n    //                 .addFrame(Frame.create(296, 341, 74, 57))\n    //                 .addFrame(Frame.create(296, 341, 74, 57))\n    //                 .play()\n    //         )\n    //         .addAnimation('Hurt',\n    //             Animation.create('resources/enemy_golem/golem-Sheet.png')\n    //                 .setRate(4)\n    //                 .setLoop(false)\n    //                 .addFrame(Frame.create(370, 227, 74, 57))\n    //                 .addFrame(Frame.create(0, 284, 74, 57))\n    //                 .addFrame(Frame.create(74, 284, 74, 57))\n    //                 .play()\n    //         )\n    //         .addAnimation('Attack/Primary',\n    //             Animation.create('resources/enemy_golem/golem-Sheet.png')\n    //                 .setRate(4)\n    //                 .setLoop(false)\n    //                 .addFrame(Frame.create(0, 170, 74, 57))\n    //                 .addFrame(Frame.create(74, 170, 74, 57))\n    //                 .addFrame(Frame.create(148, 170, 74, 57))\n    //                 .addFrame(Frame.create(222, 170, 74, 57))\n    //                 .addFrame(Frame.create(296, 170, 74, 57))\n    //                 .addFrame(Frame.create(370, 170, 74, 57))\n    //                 .addFrame(Frame.create(0, 227, 74, 57))\n    //                 .addFrame(Frame.create(74, 227, 74, 57))\n    //                 .addFrame(Frame.create(148, 227, 74, 57))\n    //                 .addFrame(Frame.create(222, 227, 74, 57))\n    //                 .addFrame(Frame.create(296, 227, 74, 57))\n    //                 .play()\n    //         )\n    //         .addAnimation('Attack/Secondary',\n    //             Animation.create('resources/enemy_golem/golem-Sheet.png')\n    //                 .setRate(4)\n    //                 .setLoop(false)\n    //                 .addFrame(Frame.create(370, 56, 74, 57))\n    //                 .addFrame(Frame.create(0, 113, 74, 57))\n    //                 .addFrame(Frame.create(74, 113, 74, 57))\n    //                 .addFrame(Frame.create(148, 113, 74, 57))\n    //                 .addFrame(Frame.create(222, 113, 74, 57))\n    //                 .addFrame(Frame.create(296, 113, 74, 57))\n    //                 .addFrame(Frame.create(370, 113, 74, 57))\n    //                 .play()\n    //         )\n    //         .addAnimation('Walk',\n    //             Animation.create('resources/enemy_golem/golem-Sheet.png')\n    //                 .setRate(4)\n    //                 .addFrame(Frame.create(370, 0, 74, 57))\n    //                 .addFrame(Frame.create(0, 56, 74, 57))\n    //                 .addFrame(Frame.create(74, 56, 74, 57))\n    //                 .addFrame(Frame.create(148, 56, 74, 57))\n    //                 .addFrame(Frame.create(222, 56, 74, 57))\n    //                 .addFrame(Frame.create(296, 56, 74, 57))\n    //                 .play()\n    //         )\n    //         .setBehavior((self) => {\n    //             const player = engine.getScene().getEntity('Player');\n    //             const distance = self.getDistanceFrom(player);\n    //\n    //             if (!self.isAlive()) {\n    //                 return;\n    //             }\n    //\n    //             self.setFlipX(player.getCalculatedCenter().getX() > self.getCalculatedCenter().getX());\n    //\n    //             // Only process other animations if we're not currently in the middle of a loop animation.\n    //             if (self.getAnimation().getLoop() || !self.getAnimation().isPlaying) {\n    //                 if (distance < 50) {\n    //                     self.setAnimation(Math.random() < 0.2 ? 'Attack/Primary' : 'Attack/Secondary');\n    //\n    //                     switch (self.getAnimationName()) {\n    //                         case 'Attack/Primary':\n    //                             engine.getScene().getCamera().setTimeline(\n    //                                 Timeline.create([\n    //                                     Sequence.create((value) => engine.getScene().getCamera().setShake(value))\n    //                                         .addKeyFrame(KeyFrame.create(new Vector2f(0, 6), 1))\n    //                                         .addKeyFrame(KeyFrame.create(new Vector2f(6, 0), 0.2))\n    //                                         .addKeyFrame(KeyFrame.create(new Vector2f(0, 8), 1.2))\n    //                                         .addKeyFrame(KeyFrame.create(new Vector2f(8, 0), 0.2))\n    //                                 ])\n    //                             );\n    //                             break;\n    //\n    //                         case 'Attack/Secondary':\n    //                             engine.getScene().getCamera().setTimeline(\n    //                                 Timeline.create([\n    //                                     Sequence.create((value) => engine.getScene().getCamera().setShake(value))\n    //                                         .addKeyFrame(KeyFrame.create(new Vector2f(0, 0), 0.3))\n    //                                         .addKeyFrame(KeyFrame.create(new Vector2f(0, 4), 0.7))\n    //                                         .addKeyFrame(KeyFrame.create(new Vector2f(4, 0), 0.2))\n    //                                 ])\n    //                             );\n    //                             break;\n    //                     }\n    //                 }\n    //                 else {\n    //                     // Handle enemy movement.\n    //                     if (distance > 100) {\n    //                         let difference = new Vector2f(\n    //                             player.getCalculatedCenter().getX() - self.getCalculatedCenter().getX(),\n    //                             player.getCalculatedCenter().getY() - self.getCalculatedCenter().getY()\n    //                         );\n    //\n    //                         self.getAcceleration().add(new Vector2f(\n    //                             difference.getX() > 0 ? 0.02 : -0.02,\n    //                             difference.getY() > 0 ? 0.02 : -0.02\n    //                         ));\n    //                     }\n    //\n    //                     self.setAnimation(self.inMotion() ? 'Walk' : 'Idle');\n    //                 }\n    //             }\n    //             else {\n    //                 // Deal player damage on certain frames within range.\n    //                 switch (self.getAnimationName()) {\n    //                     case 'Attack/Primary':\n    //                         if (Sprite.inRange(distance, 10, 70, true) && [3, 4, 7, 8].includes(self.getAnimation().getCurrentFrame())) {\n    //                             player.callEvents('UpdateHealth',\n    //                                 new UpdateHealthPayload(self, player, 20 + Math.floor(Math.random() * 10))\n    //                             )\n    //                         }\n    //                         break;\n    //\n    //                     case 'Attack/Secondary':\n    //                         if (Sprite.inRange(distance, 30, 70, true) && [2, 3].includes(self.getAnimation().getCurrentFrame())) {\n    //                             player.callEvents('UpdateHealth',\n    //                                 new UpdateHealthPayload(self, player, 10 + Math.floor(Math.random() * 10))\n    //                             )\n    //                         }\n    //                         break;\n    //                 }\n    //             }\n    //         });\n    // })\n    // .addEntity('Boss/Imp', () => {\n    //     return ISprite.create()\n    //         .setSolid(true)\n    //         .setScale(new Vector2f(1.6, 1.6))\n    //         .setPosition(new Vector2f(215, 50))\n    //         .addAnimation('Idle',\n    //             Animation.create('resources/enemy_imp/imp-Sheet.png')\n    //                 .setRate(6)\n    //                 .addFrame(Frame.create(11, 1, 43, 41))\n    //                 .addFrame(Frame.create(59, 1, 43, 41, new Vector2f(-3, 2)))\n    //                 .addFrame(Frame.create(111, 1, 43, 41, new Vector2f(-1, 6)))\n    //                 .addFrame(Frame.create(155, 1, 43, 41, new Vector2f(-10, 9)))\n    //                 .addFrame(Frame.create(206, 1, 43, 41, new Vector2f(-8, 4)))\n    //                 .play()\n    //         );\n    // })\n    // .addEntity('Boss/PhantomKnight', () => {\n    //     return ISprite.create()\n    //         .setSolid(true)\n    //         .setScale(new Vector2f(1.6, 1.6))\n    //         .setPosition(new Vector2f(20, 100))\n    //         .addAnimation('Idle',\n    //             Animation.create('resources/enemy_phantom_knight/phantom knight-Sheet.png')\n    //                 .setRate(5)\n    //                 .addFrame(Frame.create(13, 13, 29, 37))\n    //                 .addFrame(Frame.create(70, 13, 29, 37))\n    //                 .addFrame(Frame.create(127, 13, 29, 37))\n    //                 .addFrame(Frame.create(184, 13, 29, 37))\n    //                 .play()\n    //         );\n    // })\n    // .addEntity('Boss/Satyr', () => {\n    //     return ISprite.create()\n    //         .setSolid(true)\n    //         .setScale(new Vector2f(1.6, 1.6))\n    //         .setPosition(new Vector2f(245, 100))\n    //         .addAnimation('Idle',\n    //             Animation.create('resources/enemy_satyr/satyr-Sheet.png')\n    //                 .setRate(4)\n    //                 .addFrame(Frame.create(21, 12, 43, 33))\n    //                 .addFrame(Frame.create(89, 12, 41, 33))\n    //                 .addFrame(Frame.create(157, 12, 42, 33))\n    //                 .addFrame(Frame.create(225, 12, 41, 33))\n    //                 .play()\n    //         );\n    // });\n    // Cut the GUI tileset.\n\n    engine.getScene().addEntity('GUI/ExperienceFrame', _Entity_Sprite__WEBPACK_IMPORTED_MODULE_4__.Sprite.create().setVisible(false).addAnimation('Default', _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__.Animation.create('resources/pack_rpg_ui/bars/bar_224.png'))).addEntity('GUI/ExperienceBar', _Entity_Sprite__WEBPACK_IMPORTED_MODULE_4__.Sprite.create().setVisible(false).addAnimation('Default', _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__.Animation.create('resources/pack_rpg_ui/bars/bar_226.png').addFrame(_Graphic_Frame__WEBPACK_IMPORTED_MODULE_1__.Frame.create(2, 3, 20, 2)))).addEntity('GUI/HealthFrame', _Entity_Sprite__WEBPACK_IMPORTED_MODULE_4__.Sprite.create().setVisible(false).addAnimation('Default', _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__.Animation.create('resources/pack_rpg_ui/bars/bar_56.png'))).addEntity('GUI/HealthBar', _Entity_Sprite__WEBPACK_IMPORTED_MODULE_4__.Sprite.create().setVisible(false).addAnimation('Default', _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__.Animation.create('resources/pack_rpg_ui/bars/bar_76.png').addFrame(_Graphic_Frame__WEBPACK_IMPORTED_MODULE_1__.Frame.create(2, 3, 20, 2)))).addEntity('GUI/TopLeft', _Entity_Sprite__WEBPACK_IMPORTED_MODULE_4__.Sprite.create().setVisible(false).addAnimation('Default', _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__.Animation.create('resources/pack_rpg_ui/Windows/_sheet_window_06.png').addFrame(_Graphic_Frame__WEBPACK_IMPORTED_MODULE_1__.Frame.create(0, 0, 16, 16)))).addEntity('GUI/Top', _Entity_Sprite__WEBPACK_IMPORTED_MODULE_4__.Sprite.create().setVisible(false).addAnimation('Default', _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__.Animation.create('resources/pack_rpg_ui/Windows/_sheet_window_06.png').addFrame(_Graphic_Frame__WEBPACK_IMPORTED_MODULE_1__.Frame.create(16, 0, 16, 16)))).addEntity('GUI/TopRight', _Entity_Sprite__WEBPACK_IMPORTED_MODULE_4__.Sprite.create().setVisible(false).addAnimation('Default', _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__.Animation.create('resources/pack_rpg_ui/Windows/_sheet_window_06.png').addFrame(_Graphic_Frame__WEBPACK_IMPORTED_MODULE_1__.Frame.create(32, 0, 16, 16)))).addEntity('GUI/Right', _Entity_Sprite__WEBPACK_IMPORTED_MODULE_4__.Sprite.create().setVisible(false).addAnimation('Default', _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__.Animation.create('resources/pack_rpg_ui/Windows/_sheet_window_06.png').addFrame(_Graphic_Frame__WEBPACK_IMPORTED_MODULE_1__.Frame.create(32, 16, 16, 16)))).addEntity('GUI/BottomRight', _Entity_Sprite__WEBPACK_IMPORTED_MODULE_4__.Sprite.create().setVisible(false).addAnimation('Default', _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__.Animation.create('resources/pack_rpg_ui/Windows/_sheet_window_06.png').addFrame(_Graphic_Frame__WEBPACK_IMPORTED_MODULE_1__.Frame.create(32, 32, 16, 16)))).addEntity('GUI/Bottom', _Entity_Sprite__WEBPACK_IMPORTED_MODULE_4__.Sprite.create().setVisible(false).addAnimation('Default', _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__.Animation.create('resources/pack_rpg_ui/Windows/_sheet_window_06.png').addFrame(_Graphic_Frame__WEBPACK_IMPORTED_MODULE_1__.Frame.create(16, 32, 16, 16)))).addEntity('GUI/BottomLeft', _Entity_Sprite__WEBPACK_IMPORTED_MODULE_4__.Sprite.create().setVisible(false).addAnimation('Default', _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__.Animation.create('resources/pack_rpg_ui/Windows/_sheet_window_06.png').addFrame(_Graphic_Frame__WEBPACK_IMPORTED_MODULE_1__.Frame.create(0, 32, 16, 16)))).addEntity('GUI/Left', _Entity_Sprite__WEBPACK_IMPORTED_MODULE_4__.Sprite.create().setVisible(false).addAnimation('Default', _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__.Animation.create('resources/pack_rpg_ui/Windows/_sheet_window_06.png').addFrame(_Graphic_Frame__WEBPACK_IMPORTED_MODULE_1__.Frame.create(0, 16, 16, 16)))).addEntity('GUI/Center', _Entity_Sprite__WEBPACK_IMPORTED_MODULE_4__.Sprite.create().setVisible(false).addAnimation('Default', _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__.Animation.create('resources/pack_rpg_ui/Windows/_sheet_window_06.png').addFrame(_Graphic_Frame__WEBPACK_IMPORTED_MODULE_1__.Frame.create(16, 16, 16, 16))));\n    engine.getScene().getEntity('Player').setPosition(playerStart);\n    engine.getScene().addEntity('Tileset', _Entity_Sprite__WEBPACK_IMPORTED_MODULE_4__.Sprite.create('resources/pack_som/tiles_1.png').setVisible(false)); // Add a linked sprite camera.\n\n    engine.getScene().addCamera('Default', _Scene_Camera__WEBPACK_IMPORTED_MODULE_2__.Camera.create().setSprite(_Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('Player')).setZoom(2));\n    Game.sceneNodes.setValue(Game.scenePosition, engine.getScene());\n  }\n  /**\n   * Handles the gameplay.\n   */\n\n\n  getGameplay() {\n    const engine = _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getInstance(); // For controls that should act as a single fire, we'll immediately remove the active state.\n\n    engine.getController().setState('LeftShift', false); // Render the UI elements.\n\n    let frame = 50;\n    let margin = 5;\n    let origin = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(_Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getInstance().getCanvasWidth() / 2 - frame * 3 / 2, _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getInstance().getCanvasHeight() - (frame + margin));\n\n    for (let i = 0; i < 3; i++) {\n      Game.getGUIFrame(new _Math_Vector4f__WEBPACK_IMPORTED_MODULE_7__.Vector4f(origin.getX() + (frame + margin) * i, origin.getY(), frame, frame));\n      _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.text(i + 1, new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(origin.getX() + (frame + margin) * i + 9, origin.getY() + 16), 6);\n    }\n\n    _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/HealthFrame').setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(6.8, 2)).setPosition(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(origin.getX() - 2, origin.getY() - 15));\n    _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/HealthBar').setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(6.8 * (_Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('Player').getAttribute('Health') / _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('Player').getAttribute('MaxHealth')), 2)).setPosition(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(origin.getX() + 12, origin.getY() - 9));\n    _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/ExperienceFrame').setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(6.8, 2)).setPosition(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(origin.getX() - 2, origin.getY() - 27));\n    _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/ExperienceBar').setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(6.8, 2)).setPosition(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(origin.getX() + 12, origin.getY() - 21));\n    Game.drawSprite(_Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/ExperienceFrame'));\n    Game.drawSprite(_Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/ExperienceBar'));\n    Game.drawSprite(_Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/HealthFrame'));\n    Game.drawSprite(_Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('GUI/HealthBar')); // Display the tile map for debugging purposes.\n\n    if (engine.getController().getState('TildeKey')) {\n      let tilePosition = engine.getController().getMousePosition();\n      tilePosition.setX(Math.floor(tilePosition.getX() / 16)).setY(Math.floor(tilePosition.getY() / 16));\n      _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.rectangle(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(0, 0), new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(_Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('Tileset').getAnimation().getFrame().getW(), _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('Tileset').getAnimation().getFrame().getH()), '#000000');\n      Game.drawSprite(_Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.getEntity('Tileset'));\n      _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.rectangle(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(tilePosition.getX() * 16, tilePosition.getY() * 16), new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(16, 16), '#ff0000', 1, 'Stroke');\n      _Kernel_Engine__WEBPACK_IMPORTED_MODULE_3__.Engine.text(`X: ${tilePosition.getX()}, Y: ${tilePosition.getY()}, I: ${tilePosition.getY() * 30 + tilePosition.getX()}`, new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_6__.Vector2f(5, 14), 8, '#ffffff', 1);\n    }\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Example/Procedural/Game.js?");

/***/ }),

/***/ "./src/Example/Procedural/Generation/Generator.js":
/*!********************************************************!*\
  !*** ./src/Example/Procedural/Generation/Generator.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Generator\": () => (/* binding */ Generator)\n/* harmony export */ });\n/* harmony import */ var _Path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Path */ \"./src/Example/Procedural/Generation/Path.js\");\n/* harmony import */ var _Entity_Tile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Entity/Tile */ \"./src/Entity/Tile.js\");\n/* harmony import */ var _Scene_Scene__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../Scene/Scene */ \"./src/Scene/Scene.js\");\n/* harmony import */ var _Graphic_Layer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../Graphic/Layer */ \"./src/Graphic/Layer.js\");\n/* harmony import */ var _Graphic_Frame__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../Graphic/Frame */ \"./src/Graphic/Frame.js\");\n/* harmony import */ var _Math_Matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../Math/Matrix */ \"./src/Math/Matrix.js\");\n/* harmony import */ var _Entity_ISprite__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Entity/ISprite */ \"./src/Example/Procedural/Entity/ISprite.js\");\n/* harmony import */ var _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../Math/Vector2f */ \"./src/Math/Vector2f.js\");\n/* harmony import */ var _Math_Vector4f__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../Math/Vector4f */ \"./src/Math/Vector4f.js\");\n/* harmony import */ var _Entity_AutoTile__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../Entity/AutoTile */ \"./src/Entity/AutoTile.js\");\n\n\n\n\n\n\n\n\n\n\nclass Generator {\n  /**\n   * Generator constructor.\n   *\n   * @param area\n   * @param src\n   * @param layout\n   */\n  constructor(area, src, layout) {\n    // Controls various generational aspects.\n    this.maxHeight = 1;\n    this.pathBreak = 0.1;\n    this.pathWidth = 2;\n    this.pathChance = 0.1;\n    this.totalDecorations = 20;\n    this.totalRegions = 10;\n    this.totalAccessories = 20;\n    this.totalRegionTiles = 500; // Organize various defaults.\n\n    this.src = src;\n    this.area = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(50, 50);\n    this.paths = [];\n    this.scene = _Scene_Scene__WEBPACK_IMPORTED_MODULE_2__.Scene.create();\n    this.height = _Math_Matrix__WEBPACK_IMPORTED_MODULE_5__.Matrix.create(this.getArea());\n    this.layout = layout;\n    this.regions = [];\n    this.textures = {\n      'Variants': [_Entity_AutoTile__WEBPACK_IMPORTED_MODULE_9__.AutoTile.create('Weeds').getFromIndex(427, new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(30, 16)), _Entity_AutoTile__WEBPACK_IMPORTED_MODULE_9__.AutoTile.create('Flowers').getFromIndex(310, new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(30, 16))],\n      'Dirt': _Entity_AutoTile__WEBPACK_IMPORTED_MODULE_9__.AutoTile.create('Dirt').getFromIndex(307, new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(30, 16)),\n      'Grass': _Entity_AutoTile__WEBPACK_IMPORTED_MODULE_9__.AutoTile.create('Grass', _Math_Matrix__WEBPACK_IMPORTED_MODULE_5__.Matrix.create().setData([[240, 241, 242], [270, 271, 272], [300, 301, 302], [330, 331, 332]])),\n      'Cliff': _Entity_AutoTile__WEBPACK_IMPORTED_MODULE_9__.AutoTile.create('Cliff', _Math_Matrix__WEBPACK_IMPORTED_MODULE_5__.Matrix.create().setData([[271, 271, 271], [288, 289, 290], [222, 271, 226], [252, 253, 225], [192, 193, 194, 195]])),\n      'Accessories': _Entity_AutoTile__WEBPACK_IMPORTED_MODULE_9__.AutoTile.create('Accessories', new _Math_Matrix__WEBPACK_IMPORTED_MODULE_5__.Matrix().setData([[42, 42, 42], [72, 102, 103], [104, 75, 78]]))\n    };\n    this.decorations = [];\n    this.setArea(area).getAssignedScene().setArea(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(this.getArea().getX() * 16, this.getArea().getY() * 16)); // Various set combinations.\n\n    this.sets = {\n      'Grassland': () => {\n        this.maxHeight = 1;\n        this.pathBreak = 0.1;\n        this.pathWidth = 3;\n        this.pathChance = 0.1;\n        this.totalRegions = 20;\n        this.totalDecorations = 25;\n        this.totalAccessories = 45;\n        this.totalRegionTiles = 800;\n        this.decorations = [// Tree (lg)\n        _Entity_ISprite__WEBPACK_IMPORTED_MODULE_6__.ISprite.create('resources/pack_som/tiles_1.png', _Graphic_Frame__WEBPACK_IMPORTED_MODULE_4__.Frame.create(400, 0, 80, 96)).setSolid(true).setCollisionRect(new _Math_Vector4f__WEBPACK_IMPORTED_MODULE_8__.Vector4f(20, 64, 40, 32)).setZIndex(5), // Weeds\n        _Entity_ISprite__WEBPACK_IMPORTED_MODULE_6__.ISprite.create('resources/pack_som/tiles_1.png', _Graphic_Frame__WEBPACK_IMPORTED_MODULE_4__.Frame.create(304, 192, 32, 32)).setSolid(false).setZIndex(5)];\n        this.textures['Variants'] = [_Entity_AutoTile__WEBPACK_IMPORTED_MODULE_9__.AutoTile.create('Weeds').getFromIndex(427, new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(30, 16)), _Entity_AutoTile__WEBPACK_IMPORTED_MODULE_9__.AutoTile.create('Flowers').getFromIndex(310, new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(30, 16))];\n      },\n      'Mountains': () => {\n        this.maxHeight = 4;\n        this.pathBreak = 0.2;\n        this.pathWidth = 2;\n        this.pathChance = 0.25;\n        this.totalRegions = 12;\n        this.totalDecorations = 35;\n        this.totalAccessories = 20;\n        this.totalRegionTiles = 400;\n        this.decorations = [// Bush 1\n        _Entity_ISprite__WEBPACK_IMPORTED_MODULE_6__.ISprite.create('resources/pack_som/tiles_1.png', _Graphic_Frame__WEBPACK_IMPORTED_MODULE_4__.Frame.create(336, 112, 48, 48)).setSolid(true).setZIndex(5), // Rock 1\n        _Entity_ISprite__WEBPACK_IMPORTED_MODULE_6__.ISprite.create('resources/pack_som/tiles_1.png', _Graphic_Frame__WEBPACK_IMPORTED_MODULE_4__.Frame.create(400, 160, 32, 32)).setSolid(true).setZIndex(5), // Rock 2\n        _Entity_ISprite__WEBPACK_IMPORTED_MODULE_6__.ISprite.create('resources/pack_som/tiles_1.png', _Graphic_Frame__WEBPACK_IMPORTED_MODULE_4__.Frame.create(400, 96, 32, 32)).setSolid(true).setZIndex(5)];\n        this.textures['Variants'] = [// AutoTile.create('Weeds').getFromIndex(427, new Vector2f(30, 16)),\n        _Entity_AutoTile__WEBPACK_IMPORTED_MODULE_9__.AutoTile.create('Flowers').getFromIndex(310, new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(30, 16))];\n      }\n    };\n    this.sets[Object.keys(this.sets)[Math.floor(Math.random() * Object.keys(this.sets).length)]]();\n  }\n  /**\n   * Returns the assigned scene.\n   *\n   * @returns {Scene|*}\n   */\n\n\n  getAssignedScene() {\n    return this.scene;\n  }\n  /**\n   * Returns a random element from an array.\n   *\n   * @param arr\n   * @returns {*}\n   */\n\n\n  static getRandomElement(arr) {\n    return arr[Math.floor(Math.random() * arr.length)];\n  }\n  /**\n   * Returns the tile map source.\n   *\n   * @returns {string}\n   */\n\n\n  getSource() {\n    return this.src;\n  }\n  /**\n   * Returns the tile map layout.\n   *\n   * @returns {Vector2f}\n   */\n\n\n  getLayout() {\n    return this.layout;\n  }\n  /**\n   * Returns the map area.\n   *\n   * @returns {Vector2f}\n   */\n\n\n  getArea() {\n    return this.area;\n  }\n  /**\n   * Assigns the area.\n   *\n   * @param area\n   * @returns {Generator}\n   */\n\n\n  setArea(area) {\n    if (!area || !area instanceof _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f) {\n      return this;\n    }\n\n    this.area = area;\n    this.height = _Math_Matrix__WEBPACK_IMPORTED_MODULE_5__.Matrix.create(this.getArea());\n    return this;\n  }\n  /**\n   * Assigns a base tile to cover the entire layer.\n   *\n   * @param layer\n   * @returns {Generator}\n   */\n\n\n  addBaseTileToLayer(layer) {\n    for (let y = 0; y < this.getArea().getY(); y++) {\n      for (let x = 0; x < this.getArea().getX(); x++) {\n        layer.addTile(_Entity_Tile__WEBPACK_IMPORTED_MODULE_1__.Tile.create(Generator.getRandomElement(this.getTexture('Grass').toArray()), new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(x * 16, y * 16)));\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Adds a new region.\n   *\n   * @param region\n   * @returns {Generator}\n   */\n\n\n  addRegion(region) {\n    if (!region instanceof _Math_Vector4f__WEBPACK_IMPORTED_MODULE_8__.Vector4f) {\n      return this;\n    }\n\n    this.regions.push(region);\n    return this;\n  }\n  /**\n   * Returns all available regions.\n   *\n   * @returns {Array}\n   */\n\n\n  getRegions() {\n    return this.regions;\n  }\n  /**\n   * Adds a new path to storage.\n   *\n   * @param path\n   * @returns {Generator}\n   */\n\n\n  addPath(path) {\n    if (!path instanceof _Path__WEBPACK_IMPORTED_MODULE_0__.Path) {\n      return this;\n    }\n\n    this.paths.push(path);\n    return this;\n  }\n  /**\n   * Returns all available paths.\n   *\n   * @returns {Array}\n   */\n\n\n  getPaths() {\n    return this.paths;\n  }\n  /**\n   * Appends unique texture variation regions throughout the map.\n   *\n   * @param layer\n   * @param totalRegions\n   * @param totalTiles\n   * @returns {Generator}\n   */\n\n\n  addRegionsToLayer(layer, totalRegions, totalTiles) {\n    let total = 0.00; // Each region has a randomized position within the map area, as well as a weighted probability of being\n    // selected for placement while iterating through the input total tile count. Additionally, we store ahead\n    // of time which texture variant will actually be used for the region.\n    //\n\n    for (let i = 0; i < totalRegions; i++) {\n      let value = Math.random();\n      total += value;\n      this.addRegion(new _Math_Vector4f__WEBPACK_IMPORTED_MODULE_8__.Vector4f(Math.floor(Math.random() * this.getArea().getX()), Math.floor(Math.random() * this.getArea().getY()), total + value, Generator.getRandomElement(this.getTexture('Variants'))));\n    } // Place tiles within our regions. Using the weighted probability, we can randomly select a region. Regions\n    // with a higher probability will be more likely to actually have a tile placed within it somewhere. The size\n    // of the selected region is also randomized.\n    //\n\n\n    for (let i = 0; i < totalTiles; i++) {\n      let value = Math.random() * total;\n\n      for (let j = 0; j < this.getRegions().length; j++) {\n        if (value > this.getRegions()[j].getW()) {\n          continue;\n        }\n\n        let scalar = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(Math.random() * 20 + 5, Math.random() * 20 + 5);\n        let position = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f((this.getRegions()[j].getX() + Math.floor((Math.random() - 0.5) * scalar.getX())) * 16, (this.getRegions()[j].getY() + Math.floor((Math.random() - 0.5) * scalar.getY())) * 16);\n        let tile = this.getRegions()[j].getH().getRootTile();\n        let existing = layer.find(position);\n        let passes = 0;\n        let maxPasses = 10; // Ensure that each placement is unique. We can iterate against a loop here with a pre-\n        // defined max pass value to avoid endless loops in an attempt to find an open spot.\n        //\n\n        while (existing && existing.getIndex() === tile && passes < maxPasses) {\n          position = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f((this.getRegions()[j].getX() + Math.floor((Math.random() - 0.5) * scalar.getX())) * 16, (this.getRegions()[j].getY() + Math.floor((Math.random() - 0.5) * scalar.getX())) * 16);\n          existing = layer.find(position);\n          passes++;\n        }\n\n        if (existing) {\n          existing.setIndex(tile);\n        }\n\n        break;\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Used to carve paths within the scene.\n   *\n   * @param layer\n   * @param layerAbove\n   * @returns {this}\n   */\n\n\n  addPathsToScene(layer, layerAbove) {\n    if (!this.getPaths().length) {\n      this.addPath(new _Path__WEBPACK_IMPORTED_MODULE_0__.Path(this.getArea()));\n    }\n\n    for (let j = 0; j < this.getPaths().length; j++) {\n      let path = this.getPaths()[j];\n\n      for (let i = 0; i < path.length; i++) {\n        let tile = layer.find(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(path.getStart().getX() * 16, path.getStart().getY() * 16)); // Handle path collision. If a path collides with another path, we'll basically just terminate\n        // the current procedure and act as if both paths join since that is the more realistic behavior.\n        //\n\n        if (tile && tile.getAttribute('Paths/Related') && tile.getAttribute('Paths/Related') !== path) {\n          continue;\n        } // Add some width to the path. Additionally, each path tile has a chance of just being a normal base\n        // tile for some added variation. In the future, we can add more diversity at this point.\n        //\n\n\n        for (let k = 0; k < this.pathWidth; k++) {\n          for (let l = 0; l < this.pathWidth; l++) {\n            let neighbor = layer.find(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f((path.getStart().getX() + l) * 16, (path.getStart().getY() + k) * 16));\n\n            if (neighbor) {\n              neighbor.setIndex(Math.random() <= 1.0 - this.pathBreak ? this.getTexture('Dirt').getRootTile() : Generator.getRandomElement(this.getTexture('Grass').toArray())).setAttribute('Paths/Related', path);\n            } // Since we are also handling multiple layers across the scene, we'll also verify that the\n            // path generation isn't being blocked by an overhead tile from one of the wall / cliff maps.\n            //\n\n\n            neighbor = layerAbove.find(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f((path.getStart().getX() + l) * 16, (path.getStart().getY() + k) * 16));\n\n            if (neighbor) {\n              neighbor.setVisible(false);\n            }\n          }\n        } // Choose a random direction to move in based on the current path direction and the generated\n        // weighted probability \"walking\" matrix (favors a shift in the current path direction).\n        //\n\n\n        let shift = _Path__WEBPACK_IMPORTED_MODULE_0__.Path.getWeightedRandom(path.getWalk().getDetails(), path.getWalk().asArray());\n        path.getStart().setX(path.getStart().getX() + (shift.getX() - 1));\n        path.getStart().setY(path.getStart().getY() + (shift.getY() - 1)); // Only generate a new path if we haven't exceeded the max paths and we're within an appropriate\n        // drawing window (to prevent paths that border the edge of the scene). To account for this, we'll\n        // shift our boundary in by 10 tiles on all directions before even having an opportunity to spawn\n        // a new path.\n        //\n\n        let chance = Math.random();\n\n        if (chance < this.pathChance && this.getPaths().length < 10 && path.getStart().getX() > 10 && path.getStart().getX() < this.getArea().getX() - 10 && path.getStart().getY() > 10 && path.getStart().getY() < this.getArea().getY() - 10) {\n          let spawn = new _Path__WEBPACK_IMPORTED_MODULE_0__.Path(this.getArea());\n\n          if (spawn.getDirection() === path.getDirection()) {\n            while (spawn.getDirection() === path.getDirection() || spawn.getDirection() === path.getDirection() - 1 || spawn.getDirection() === path.getDirection() + 1) {\n              spawn.getRandomDirection();\n            }\n          }\n\n          spawn.setStart(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(path.getStart().getX() + Math.floor((Math.random() - 0.5) * 3), path.getStart().getY() + Math.floor((Math.random() - 0.5) * 3)));\n          this.addPath(spawn);\n        }\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Used to generate hills on the scene.\n   *\n   * @param layer\n   * @param layerAbove\n   * @param maxHeight\n   * @returns {this}\n   */\n\n\n  addHeightToScene(layer, layerAbove, maxHeight) {\n    noise.seed(Math.random());\n    let minimumHeight = 0;\n\n    for (let y = 0; y < this.getArea().getY(); y++) {\n      for (let x = 0; x < this.getArea().getX(); x++) {\n        let tile = layer.find(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(x * 16, y * 16));\n        let nx = x / this.getArea().getX() - 0.5;\n        let ny = y / this.getArea().getY() - 0.5;\n        this.getHeightMap().setValue(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(x, y), Math.floor(noise.simplex2(nx, ny) * maxHeight));\n\n        if (this.getHeightMap().getValue(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(x, y)) < minimumHeight) {\n          minimumHeight = this.getHeightMap().getValue(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(x, y));\n        }\n\n        if (tile && tile.getIndex() === this.getTexture('Dirt').getRootTile()) {\n          this.getHeightMap().setValue(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(x, y), this.getHeightMap().getValue(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(x, y)) - 1);\n        }\n      }\n    }\n\n    for (let i = maxHeight; i >= minimumHeight; i--) {\n      for (let y = 0; y < this.getArea().getY(); y++) {\n        for (let x = 0; x < this.getArea().getX(); x++) {\n          let sum = 0;\n          let index = this.getHeightMap().getValue(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(x, y));\n          let tile = layer.find(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(x * 16, y * 16));\n\n          if (!tile) {\n            continue;\n          }\n\n          if (tile.getIndex() === this.getTexture('Dirt').getRootTile()) {\n            continue;\n          }\n\n          if (index !== i) {\n            continue;\n          }\n\n          sum += !y || this.getHeightMap().getValue(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(x, y - 1)) <= index ? 1 : 0;\n          sum += x === this.getArea().getX() - 1 || this.getHeightMap().getValue(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(x + 1, y)) <= index ? 4 : 0;\n          sum += y === this.getArea().getY() - 1 || this.getHeightMap().getValue(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(x, y + 1)) <= index ? 8 : 0;\n          sum += !x || this.getHeightMap().getValue(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(x - 1, y)) <= index ? 2 : 0;\n\n          if (sum === 0 || sum === 15) {\n            continue;\n          }\n\n          if (_Entity_AutoTile__WEBPACK_IMPORTED_MODULE_9__.AutoTile.isBitmaskCeiling(sum)) {\n            layerAbove.addTile(new _Entity_Tile__WEBPACK_IMPORTED_MODULE_1__.Tile(this.getTexture('Cliff').getFromBitmask(sum), new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(x * 16, y * 16)));\n            let tile = layer.find(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(x * 16, (y + 1) * 16));\n\n            if (tile) {\n              tile.setSolid(true);\n            }\n          } else {\n            tile.setIndex(this.getTexture('Cliff').getFromBitmask(sum)).setSolid(true);\n          }\n\n          if (_Entity_AutoTile__WEBPACK_IMPORTED_MODULE_9__.AutoTile.isBitmaskFloor(sum)) {\n            let tile = layer.find(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(x * 16, (y + 1) * 16));\n\n            if (!tile) {\n              continue;\n            }\n\n            switch (sum) {\n              case 3:\n                tile.setIndex(195).setSolid(true);\n                break;\n\n              case 5:\n                tile.setIndex(192 + Math.floor(Math.random() * 2)).setSolid(true);\n                break;\n\n              case 7:\n                tile.setIndex(193).setSolid(true);\n                break;\n            }\n          }\n        }\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Updates the auto tile regions on the map.\n   *\n   * @param layer\n   * @param layerAbove\n   */\n\n\n  addAutoTiling(layer, layerAbove) {\n    let changes = [];\n    let matrix = _Math_Matrix__WEBPACK_IMPORTED_MODULE_5__.Matrix.create(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(3, 3));\n    let variants = this.getTexture('Variants');\n    variants.push(this.getTexture('Dirt')); // Place accessory elements.\n\n    for (let i = 0; i < this.totalAccessories; i++) {\n      let position = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(Math.floor(Math.random() * this.getArea().getX()) * 16, Math.floor(Math.random() * this.getArea().getY()) * 16);\n      let existing = layer.find(position); // Verify that we're not placing the accessory in the middle of a cliff.\n\n      if (existing && !this.getTexture('Cliff').hasTile(existing.getIndex())) {\n        existing.setIndex(Generator.getRandomElement(this.getTexture('Accessories').toArray()));\n      }\n    } // Calculate our auto tile updates.\n\n\n    for (let i = 0; i < variants.length; i++) {\n      let variant = variants[i];\n\n      for (let y = 0; y < this.getArea().getY(); y++) {\n        for (let x = 0; x < this.getArea().getX(); x++) {\n          let tile = layerAbove.find(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(x * 16, y * 16));\n\n          if (!tile) {\n            tile = layer.find(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(x * 16, y * 16));\n          }\n\n          if (!tile || tile.getIndex() !== variant.getRootTile()) {\n            continue;\n          }\n\n          for (let iy = -1; iy <= 1; iy++) {\n            for (let ix = -1; ix <= 1; ix++) {\n              let neighbor = layer.find(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f((x + ix) * 16, (y + iy) * 16));\n              matrix.setValue(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(ix + 1, iy + 1), neighbor ? neighbor.getIndex() === variant.getRootTile() : true);\n            }\n          }\n\n          let sum = 0;\n          sum += matrix.getValue(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(1, 0)) ? 1 : 0;\n          sum += matrix.getValue(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(2, 1)) ? 4 : 0;\n          sum += matrix.getValue(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(1, 2)) ? 8 : 0;\n          sum += matrix.getValue(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(0, 1)) ? 2 : 0; // Handle invalid tiles.\n\n          if (!_Entity_AutoTile__WEBPACK_IMPORTED_MODULE_9__.AutoTile.isBitmaskValid(sum)) {\n            tile.setIndex(Generator.getRandomElement(this.getTexture('Grass').toArray()));\n            y--;\n            continue;\n          } // Register the update if we're actually modifying something.\n\n\n          if (variant.getFromBitmask(sum) !== variant.getRootTile()) {\n            changes.push({\n              tile: tile,\n              index: variant.getFromBitmask(sum)\n            });\n          }\n        }\n      }\n    } // Perform the calculated auto tile updates.\n\n\n    for (let i = 0; i < changes.length; i++) {\n      changes[i].tile.setIndex(changes[i].index);\n    }\n\n    return this;\n  }\n  /**\n   * Removes any byproduct cliff tiles caused from path generation.\n   *\n   * @param layerCurrent\n   * @param layerAbove\n   * @returns {Generator}\n   */\n\n\n  cleanHeightTiles(layerCurrent, layerAbove) {\n    let cliff = this.getTexture('Cliff');\n\n    for (let y = 1; y < this.getArea().getY() - 1; y++) {\n      for (let x = 1; x < this.getArea().getX() - 1; x++) {\n        let tile = layerAbove.find(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(x * 16, y * 16));\n        let neighbors = 0;\n        let isAbove = true;\n        let isWall = false;\n\n        if (!tile) {\n          tile = layerCurrent.find(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(x * 16, y * 16));\n          isAbove = false;\n        }\n\n        if (!tile || !cliff.toArray().includes(tile.getIndex())) {\n          continue;\n        }\n\n        for (let iy = -1; iy <= 1; iy++) {\n          for (let ix = -1; ix <= 1; ix++) {\n            let neighbor = layerCurrent.find(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f((x + ix) * 16, (y + iy) * 16));\n            let above = layerAbove.find(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f((x + ix) * 16, (y + iy) * 16));\n\n            if (neighbor ? [192, 193, 194, 195].includes(neighbor.getIndex()) : false) {\n              isWall = true;\n            }\n\n            if (neighbor ? cliff.toArray().includes(neighbor.getIndex()) : false) {\n              neighbors++;\n            }\n\n            if (above ? cliff.toArray().includes(above.getIndex()) : false) {\n              neighbors++;\n            }\n          }\n        }\n\n        if (neighbors === 1 || isWall && neighbors === 2) {\n          if (isAbove) {\n            tile.setVisible(false);\n          }\n\n          tile.setIndex(Generator.getRandomElement(this.getTexture('Grass').toArray())).setSolid(false);\n        }\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Returns all available textures.\n   *\n   * @returns {Object}\n   */\n\n\n  getTextures() {\n    return this.textures;\n  }\n  /**\n   * Indicates whether or not a texture is defined.\n   *\n   * @param key\n   * @returns {boolean}\n   */\n\n\n  hasTexture(key) {\n    return this.getTextures().hasOwnProperty(key);\n  }\n  /**\n   * Returns a configured texture value.\n   *\n   * @param key\n   * @returns {Array}\n   */\n\n\n  getTexture(key) {\n    return this.hasTexture(key) ? this.getTextures()[key] : [];\n  }\n  /**\n   * Returns the height map for the scene.\n   *\n   * @returns {Matrix}\n   */\n\n\n  getHeightMap() {\n    return this.height;\n  }\n  /**\n   * Returns a new scene instance.\n   *\n   * @returns {Scene}\n   */\n\n\n  getScene() {\n    let scene = this.scene;\n    let layerAbove = _Graphic_Layer__WEBPACK_IMPORTED_MODULE_3__.Layer.create(this.getSource(), this.getLayout());\n    return scene.addLayer(() => {\n      let layerCurrent = _Graphic_Layer__WEBPACK_IMPORTED_MODULE_3__.Layer.create(this.getSource(), this.getLayout());\n      this.addBaseTileToLayer(layerCurrent).addRegionsToLayer(layerCurrent, this.totalRegions, this.totalRegionTiles).addPathsToScene(layerCurrent, layerAbove).addHeightToScene(layerCurrent, layerAbove, this.maxHeight).addAutoTiling(layerCurrent, layerAbove).cleanHeightTiles(layerCurrent, layerAbove);\n\n      for (let i = 0; i < this.totalDecorations; i++) {\n        const scale = 0.8 + Math.random() * 0.5;\n        scene.addEntity(_Entity_ISprite__WEBPACK_IMPORTED_MODULE_6__.ISprite.getUniqueName('Decoration'), Generator.getRandomElement(this.decorations).clone().setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(scale, scale)).setPosition(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_7__.Vector2f(Math.floor(Math.random() * 50) * 16, Math.floor(Math.random() * 50) * 16)));\n      }\n\n      return layerCurrent;\n    }).addLayer(layerAbove);\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Example/Procedural/Generation/Generator.js?");

/***/ }),

/***/ "./src/Example/Procedural/Generation/Path.js":
/*!***************************************************!*\
  !*** ./src/Example/Procedural/Generation/Path.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Path\": () => (/* binding */ Path)\n/* harmony export */ });\n/* harmony import */ var _Math_Matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Math/Matrix */ \"./src/Math/Matrix.js\");\n/* harmony import */ var _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Math/Vector2f */ \"./src/Math/Vector2f.js\");\n\n\nclass Path {\n  /**\n   * Path constructor.\n   *\n   * @param area\n   */\n  constructor(area) {\n    this.end = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(0, 0);\n    this.area = area;\n    this.walk = new _Math_Matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(3, 3));\n    this.root = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(0, 0);\n    this.start = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(0, 0);\n    this.offset = Math.floor(Math.random() * this.getArea().getX());\n    this.length = Math.random() * (this.getArea().getY() * 2) + this.getArea().getY();\n    this.direction = 0;\n    this.getRandomDirection();\n  }\n  /**\n   * Assigns the length.\n   *\n   * @param length\n   * @returns {Path}\n   */\n\n\n  setLength(length) {\n    this.length = length;\n    return this;\n  }\n  /**\n   * Returns the length.\n   *\n   * @returns {number}\n   */\n\n\n  getLength() {\n    return this.length;\n  }\n  /**\n   * Assigns the map area.\n   *\n   * @param area\n   * @returns {Path}\n   */\n\n\n  setArea(area) {\n    if (!area || !area instanceof _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f) {\n      return this;\n    }\n\n    this.area = area;\n    return this;\n  }\n  /**\n   * Returns the area.\n   *\n   * @returns {Vector2f}\n   */\n\n\n  getArea() {\n    return this.area;\n  }\n  /**\n   * Returns the root position.\n   *\n   * @returns {Vector2f}\n   */\n\n\n  getRoot() {\n    return this.root;\n  }\n  /**\n   * Assigns the starting point.\n   *\n   * @param start\n   * @returns {Path}\n   */\n\n\n  setStart(start) {\n    if (!start instanceof _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f) {\n      return this;\n    }\n\n    this.start = start;\n    this.root = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(start.getX(), start.getY());\n    return this;\n  }\n  /**\n   * Returns the starting point.\n   *\n   * @returns {Vector2f}\n   */\n\n\n  getStart() {\n    return this.start;\n  }\n  /**\n   * Assigns the ending point.\n   *\n   * @param end\n   * @returns {Path}\n   */\n\n\n  setEnd(end) {\n    if (!end instanceof _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f) {\n      return this;\n    }\n\n    this.end = end;\n    return this;\n  }\n  /**\n   * Returns the ending point.\n   *\n   * @returns {Vector2f}\n   */\n\n\n  getEnd() {\n    return this.end;\n  }\n  /**\n   * Generates a random direction.\n   */\n\n\n  getRandomDirection() {\n    this.setDirection(Math.floor(Math.random() * 4));\n  }\n  /**\n   * Assigns a direction to the path.\n   *\n   * @param direction\n   * @returns {this}\n   */\n\n\n  setDirection(direction) {\n    this.direction = direction;\n    this.getWalkFromDirection();\n    return this;\n  }\n  /**\n   * Returns the current direction.\n   *\n   * @returns {number}\n   */\n\n\n  getDirection() {\n    return this.direction;\n  }\n  /**\n   * Returns the path / map offset.\n   *\n   * @returns {number}\n   */\n\n\n  getOffset() {\n    return this.offset;\n  }\n  /**\n   * Assigns the offset value.\n   *\n   * @param offset\n   * @returns {Path}\n   */\n\n\n  setOffset(offset) {\n    this.offset = offset;\n    return this;\n  }\n  /**\n   * Returns the \"walking\" probability matrix.\n   *\n   * @returns {Matrix}\n   */\n\n\n  getWalk() {\n    return this.walk;\n  }\n  /**\n   * Returns the walk matrix based on the direction.\n   */\n\n\n  getWalkFromDirection() {\n    switch (this.getDirection()) {\n      // Down\n      case 0:\n        this.getStart().setX(this.getOffset());\n        this.getRoot().setX(this.getOffset());\n\n        for (let y = 0; y < 3; y++) {\n          for (let x = -1; x < 2; x++) {\n            this.getWalk().setValue(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(x + 1, y), y - Math.abs(x) + 1 + (Math.random() - 0.5) / 2);\n          }\n        }\n\n        break;\n      // Up\n\n      case 1:\n        this.getStart().setY(this.getOffset());\n        this.getRoot().setY(this.getOffset());\n\n        for (let y = 0; y < 3; y++) {\n          for (let x = -1; x < 2; x++) {\n            this.getWalk().setValue(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(y, x + 1), y - Math.abs(x) + 1 + (Math.random() - 0.5) / 2);\n          }\n        }\n\n        break;\n      // Left\n\n      case 2:\n        this.getStart().setX(this.getArea().getX()).setY(this.getOffset());\n        this.getRoot().setX(this.getArea().getX()).setY(this.getOffset());\n\n        for (let y = 0; y < 3; y++) {\n          for (let x = -1; x < 2; x++) {\n            this.getWalk().setValue(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(2 - y, x + 1), y - Math.abs(x) + 1 + (Math.random() - 0.5) / 2);\n          }\n        }\n\n        break;\n      // Right\n\n      case 3:\n        this.getStart().setX(this.getOffset()).setY(this.getArea().getY());\n        this.getRoot().setX(this.getOffset()).setY(this.getArea().getY());\n\n        for (let y = 0; y < 3; y++) {\n          for (let x = -1; x < 2; x++) {\n            this.getWalk().setValue(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(x + 1, 2 - y), y - Math.abs(x) + 1 + (Math.random() - 0.5) / 2);\n          }\n        }\n\n        break;\n    }\n  }\n  /**\n   * Uses weighted probability to return a random item.\n   *\n   * @param items\n   * @param weights\n   * @returns {*}\n   */\n\n\n  static getWeightedRandom(items, weights) {\n    let i;\n\n    for (i = 0; i < weights.length; i++) weights[i] += weights[i - 1] || 0;\n\n    let random = Math.random() * weights[weights.length - 1];\n\n    for (i = 0; i < weights.length; i++) if (weights[i] > random) break;\n\n    return items[i];\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Example/Procedural/Generation/Path.js?");

/***/ }),

/***/ "./src/Graphic/Frame.js":
/*!******************************!*\
  !*** ./src/Graphic/Frame.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Frame\": () => (/* binding */ Frame)\n/* harmony export */ });\n/* harmony import */ var _Math_Vector2f__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Math/Vector2f */ \"./src/Math/Vector2f.js\");\n/* harmony import */ var _Math_Vector4f__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Math/Vector4f */ \"./src/Math/Vector4f.js\");\n\n\nclass Frame extends _Math_Vector4f__WEBPACK_IMPORTED_MODULE_1__.Vector4f {\n  /**\n   * Frame constructor.\n   *\n   * @param x\n   * @param y\n   * @param w\n   * @param h\n   * @param offset\n   */\n  constructor(x, y, w, h, offset) {\n    super(x, y, w, h);\n    this.offset = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_0__.Vector2f(0, 0);\n\n    if (offset) {\n      this.setOffset(offset);\n    }\n  }\n  /**\n   * Creates a new Frame instance.\n   *\n   * @param x\n   * @param y\n   * @param w\n   * @param h\n   * @param offset\n   * @returns {Frame}\n   */\n\n\n  static create(x, y, w, h, offset) {\n    return new Frame(x, y, w, h, offset);\n  }\n  /**\n   * Assigns the offset.\n   *\n   * @param offset\n   * @returns {this}\n   */\n\n\n  setOffset(offset) {\n    if (!offset instanceof _Math_Vector2f__WEBPACK_IMPORTED_MODULE_0__.Vector2f) {\n      return this;\n    }\n\n    this.offset = offset;\n    return this;\n  }\n  /**\n   * Returns the assigned offset.\n   *\n   * @returns {Vector2f}\n   */\n\n\n  getOffset() {\n    return this.offset;\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Graphic/Frame.js?");

/***/ }),

/***/ "./src/Graphic/Layer.js":
/*!******************************!*\
  !*** ./src/Graphic/Layer.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Layer\": () => (/* binding */ Layer)\n/* harmony export */ });\n/* harmony import */ var _Entity_Tile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity/Tile */ \"./src/Entity/Tile.js\");\n/* harmony import */ var _Frame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Frame */ \"./src/Graphic/Frame.js\");\n/* harmony import */ var _Math_Vector2f__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Math/Vector2f */ \"./src/Math/Vector2f.js\");\n/* harmony import */ var _Animation_Animation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Animation/Animation */ \"./src/Animation/Animation.js\");\n/* harmony import */ var _SpriteSheet__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SpriteSheet */ \"./src/Graphic/SpriteSheet.js\");\n\n\n\n\n\nclass Layer extends _SpriteSheet__WEBPACK_IMPORTED_MODULE_4__.SpriteSheet {\n  /**\n   * Layer constructor.\n   *\n   * @param src\n   * @param layout\n   */\n  constructor(src, layout) {\n    super(src);\n    this.zIndex = 0;\n    this.setTiles([]).setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_2__.Vector2f(1, 1)).setOffset(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_2__.Vector2f(0, 0));\n\n    if (layout) {\n      this.slice(layout);\n    }\n  }\n  /**\n   * Create a new Layer instance.\n   *\n   * @param src\n   * @param layout\n   * @returns {Layer}\n   */\n\n\n  static create(src, layout) {\n    return new Layer(src, layout);\n  }\n  /**\n   * Assigns the Z index.\n   *\n   * @param index\n   * @returns {Layer}\n   */\n\n\n  setZIndex(index) {\n    this.zIndex = index;\n    return this;\n  }\n  /**\n   * Returns the Z index.\n   *\n   * @returns {number}\n   */\n\n\n  getZIndex() {\n    return this.zIndex;\n  }\n  /**\n   * Finds a tile at the specified position.\n   *\n   * @param position\n   * @param threshold\n   */\n\n\n  find(position, threshold) {\n    threshold = threshold || 0;\n\n    if (!position instanceof _Math_Vector2f__WEBPACK_IMPORTED_MODULE_2__.Vector2f) {\n      return false;\n    }\n\n    for (let i = 0; i < this.getTiles().length; i++) {\n      if (this.getTiles()[i].getPosition().getX() >= position.getX() - threshold && this.getTiles()[i].getPosition().getX() <= position.getX() + threshold && this.getTiles()[i].getPosition().getY() >= position.getY() - threshold && this.getTiles()[i].getPosition().getY() <= position.getY() + threshold) {\n        return this.getTiles()[i];\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Used to sequentially cut frames based on the input layout.\n   *\n   * @param layout\n   * @returns {Layer}\n   */\n\n\n  slice(layout) {\n    if (!layout instanceof _Math_Vector2f__WEBPACK_IMPORTED_MODULE_2__.Vector2f) {\n      return this;\n    }\n\n    this.getResource().addEvent(() => {\n      let frameWidth = this.getDomSize().getX() / layout.getX();\n      let frameHeight = this.getDomSize().getY() / layout.getY();\n\n      for (let y = 0; y < layout.getY(); y++) {\n        for (let x = 0; x < layout.getX(); x++) {\n          this.addFrame(new _Frame__WEBPACK_IMPORTED_MODULE_1__.Frame(x * frameWidth, y * frameHeight, frameWidth, frameHeight));\n        }\n      }\n    });\n    return this;\n  }\n  /**\n   * Used to assign a global offset to all tiles under the layer.\n   *\n   * @param offset\n   * @returns {Layer}\n   */\n\n\n  setOffset(offset) {\n    if (!offset instanceof _Math_Vector2f__WEBPACK_IMPORTED_MODULE_2__.Vector2f) {\n      return this;\n    }\n\n    this.offset = offset;\n    return this;\n  }\n  /**\n   * Returns the assigned offset.\n   *\n   * @returns {Vector2f}\n   */\n\n\n  getOffset() {\n    return this.offset;\n  }\n  /**\n   * Assigns the layer scale.\n   *\n   * @param scale\n   * @returns {Layer}\n   */\n\n\n  setScale(scale) {\n    if (!scale instanceof _Math_Vector2f__WEBPACK_IMPORTED_MODULE_2__.Vector2f) {\n      return this;\n    }\n\n    this.scale = scale;\n    return this;\n  }\n  /**\n   * Returns the layer scale.\n   *\n   * @returns Vector2f\n   */\n\n\n  getScale() {\n    return this.scale;\n  }\n  /**\n   * Registers a new tile.\n   *\n   * @param tile\n   * @returns {Layer}\n   */\n\n\n  addTile(tile) {\n    if (!tile instanceof _Entity_Tile__WEBPACK_IMPORTED_MODULE_0__.Tile) {\n      return this;\n    } // As an optimization step, we'll register the assigned layer graphic to\n    // the tile to avoid a need to reload & recreate the underlying resource.\n    //\n\n\n    this.getResource().addEvent(() => {\n      if (tile.hasAnimations() || !this.getFrames().hasOwnProperty(tile.index)) {\n        return;\n      }\n\n      tile.addAnimation('Default', new _Animation_Animation__WEBPACK_IMPORTED_MODULE_3__.Animation().addFrame(this.frames[tile.index]).setResource(this.getResource()));\n    });\n    this.tiles.push(tile.setScale(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_2__.Vector2f(tile.getScale().getX() + this.getScale().getX() - 1, tile.getScale().getY() + this.getScale().getY() - 1)));\n    return this;\n  }\n  /**\n   * Returns all assigned tiles.\n   *\n   * @returns {Array}\n   */\n\n\n  getTiles() {\n    return this.tiles;\n  }\n  /**\n   * Assigns all tiles.\n   *\n   * @param tiles\n   * @returns {Layer}\n   */\n\n\n  setTiles(tiles) {\n    this.tiles = tiles;\n    return this;\n  }\n  /**\n   * Renders the layer.\n   */\n\n\n  draw() {\n    const tiles = this.getTiles();\n\n    for (let i = 0; i < tiles.length; i++) {\n      tiles[i].setZIndex(this.getZIndex()).setOffset(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_2__.Vector2f(this.getOffset().getX() + tiles[i].getPosition().getX() * (this.getScale().getX() - 1), this.getOffset().getY() + tiles[i].getPosition().getY() * (this.getScale().getY() - 1))).draw();\n    }\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Graphic/Layer.js?");

/***/ }),

/***/ "./src/Graphic/Particle.js":
/*!*********************************!*\
  !*** ./src/Graphic/Particle.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Particle\": () => (/* binding */ Particle)\n/* harmony export */ });\n/* harmony import */ var _Entity_Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity/Sprite */ \"./src/Entity/Sprite.js\");\n\nclass Particle {\n  /**\n   * Particle constructor.\n   *\n   * @param sprite\n   * @param life\n   */\n  constructor(sprite, life) {\n    this.setSprite(sprite);\n    this.life = life || 0;\n    this.alive = true;\n    this.startTime = new Date();\n  }\n  /**\n   * Assigns the sprite.\n   *\n   * @param sprite\n   * @returns {Particle}\n   */\n\n\n  setSprite(sprite) {\n    if (!sprite instanceof _Entity_Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite) {\n      return this;\n    }\n\n    this.sprite = sprite;\n    return this;\n  }\n  /**\n   * Returns the configured sprite.\n   *\n   * @returns {*}\n   */\n\n\n  getSprite() {\n    return this.sprite;\n  }\n  /**\n   * Identifies whether or not the life has been exceeded.\n   *\n   * @returns {boolean}\n   */\n\n\n  isAlive() {\n    return this.alive;\n  }\n  /**\n   * Returns the amount of time a particle is alive for.\n   *\n   * @returns {number}\n   */\n\n\n  getLife() {\n    return this.life;\n  }\n  /**\n   * Returns the start time.\n   *\n   * @returns {Date}\n   */\n\n\n  getStartTime() {\n    return this.startTime;\n  }\n  /**\n   * Returns the elapsed time for the particle.\n   *\n   * @returns {number}\n   */\n\n\n  getElapsed() {\n    return Date.now() - this.getStartTime();\n  }\n  /**\n   * Assigns the alive state.\n   *\n   * @param flag\n   * @returns {Particle}\n   */\n\n\n  setAlive(flag) {\n    this.alive = flag;\n    return this;\n  }\n  /**\n   * Used to render the particle.\n   */\n\n\n  draw() {\n    if (!this.getSprite().getVisible()) {\n      this.setAlive(false);\n    }\n\n    if (this.getLife() && this.getElapsed() > this.getLife()) {\n      this.setAlive(false);\n    }\n\n    this.getSprite().draw();\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Graphic/Particle.js?");

/***/ }),

/***/ "./src/Graphic/SpriteSheet.js":
/*!************************************!*\
  !*** ./src/Graphic/SpriteSheet.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SpriteSheet\": () => (/* binding */ SpriteSheet)\n/* harmony export */ });\n/* harmony import */ var _Frame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Frame */ \"./src/Graphic/Frame.js\");\n/* harmony import */ var _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Math/Vector2f */ \"./src/Math/Vector2f.js\");\n/* harmony import */ var _Resource_ImageResource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Resource/ImageResource */ \"./src/Resource/ImageResource.js\");\n\n\n\nclass SpriteSheet {\n  /**\n   * SpriteSheet constructor.\n   *\n   * @param src\n   */\n  constructor(src) {\n    this.frames = [];\n    this.setResource(new _Resource_ImageResource__WEBPACK_IMPORTED_MODULE_2__.ImageResource(src));\n  }\n  /**\n   * Registers a new frame.\n   *\n   * @param frame\n   * @returns this\n   */\n\n\n  addFrame(frame) {\n    if (!frame || !frame instanceof _Frame__WEBPACK_IMPORTED_MODULE_0__.Frame) {\n      return this;\n    }\n\n    this.frames.push(frame);\n    return this;\n  }\n  /**\n   * Returns the assigned frames.\n   *\n   * @returns {Array}\n   */\n\n\n  getFrames() {\n    return this.frames;\n  }\n  /**\n   * Assigns the resource.\n   *\n   * @param resource\n   * @returns this\n   */\n\n\n  setResource(resource) {\n    if (!resource instanceof _Resource_ImageResource__WEBPACK_IMPORTED_MODULE_2__.ImageResource) {\n      return this;\n    }\n\n    this.resource = resource;\n    return this;\n  }\n  /**\n   * Returns the assigned resource.\n   *\n   * @returns ImageResource\n   */\n\n\n  getResource() {\n    return this.resource;\n  }\n  /**\n   * Returns the DOM resource.\n   *\n   * @returns HTMLImageElement\n   */\n\n\n  getDomResource() {\n    return this.getResource().getElement();\n  }\n  /**\n   * Returns the calculated DOM size.\n   *\n   * @returns {Vector2f}\n   */\n\n\n  getDomSize() {\n    return new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(this.getDomResource().width, this.getDomResource().height);\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Graphic/SpriteSheet.js?");

/***/ }),

/***/ "./src/Input/Controller.js":
/*!*********************************!*\
  !*** ./src/Input/Controller.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Controller\": () => (/* binding */ Controller)\n/* harmony export */ });\n/* harmony import */ var _Kernel_State__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Kernel/State */ \"./src/Kernel/State.js\");\n/* harmony import */ var _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Math/Vector2f */ \"./src/Math/Vector2f.js\");\n\n\nclass Controller {\n  /**\n   * Controller constructor.\n   */\n  constructor() {\n    this.keys = {};\n    this.bindings = {\n      '1Key': 49,\n      '2Key': 50,\n      '3Key': 51,\n      'TildeKey': 192,\n      'Space': 32,\n      'UpArrow': 38,\n      'DownArrow': 40,\n      'LeftShift': 16,\n      'LeftArrow': 37,\n      'RightArrow': 39\n    };\n    this.mousePosition = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(0, 0);\n\n    for (let i in this.bindings) {\n      if (!this.bindings.hasOwnProperty(i)) {\n        continue;\n      }\n\n      this.keys[this.bindings[i]] = false;\n    }\n\n    this.addEventHandlers();\n  }\n  /**\n   * Refreshes all key states.\n   */\n\n\n  refresh() {\n    for (let i in this.keys) {\n      if (this.keys.hasOwnProperty(i)) {\n        this.setState(i, false);\n      }\n    }\n  }\n  /**\n   * Assigns the state of the code.\n   *\n   * @param code\n   * @param state\n   * @returns this\n   */\n\n\n  setState(code, state) {\n    if (this.bindings.hasOwnProperty(code)) {\n      code = this.bindings[code];\n    }\n\n    if (!code || !this.keys.hasOwnProperty(code)) {\n      return this;\n    }\n\n    this.keys[code] = state;\n  }\n  /**\n   * Returns the state of the specified code.\n   *\n   * @param code\n   * @returns {*}\n   */\n\n\n  getState(code) {\n    if (this.bindings.hasOwnProperty(code)) {\n      code = this.bindings[code];\n    }\n\n    if (!code || !this.keys.hasOwnProperty(code)) {\n      return false;\n    }\n\n    return this.keys[code];\n  }\n  /**\n   * Returns the unscaled mouse position.\n   *\n   * @returns {Vector2f}\n   */\n\n\n  getMousePosition() {\n    const scale = _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().getCanvasScale();\n    const offset = _Kernel_State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine().getCanvasOffset();\n    return new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(this.getRealMousePosition().getX() * (1 / scale) - offset.getX(), this.getRealMousePosition().getY() * (1 / scale) - offset.getY());\n  }\n  /**\n   * Returns the true mouse position.\n   *\n   * @returns {Vector2f}\n   */\n\n\n  getRealMousePosition() {\n    return this.mousePosition;\n  }\n  /**\n   * Binds any controller events.\n   */\n\n\n  addEventHandlers() {\n    document.onmousemove = e => {\n      this.mousePosition.setX(e.pageX).setY(e.pageY);\n    };\n\n    document.onkeydown = e => {\n      e = e || window.event;\n\n      if (e.repeat) {\n        return;\n      }\n\n      this.setState(e.keyCode, true);\n    };\n\n    document.onkeyup = e => {\n      e = e || window.event;\n\n      if (e.repeat) {\n        return;\n      }\n\n      this.setState(e.keyCode, false);\n    };\n  }\n  /**\n   * Indicates whether or not an arrow key is being utilized.\n   *\n   * @returns boolean\n   */\n\n\n  hasArrowKeyDown() {\n    return this.getState('UpArrow') || this.getState('DownArrow') || this.getState('LeftArrow') || this.getState('RightArrow');\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Input/Controller.js?");

/***/ }),

/***/ "./src/Kernel/Engine.js":
/*!******************************!*\
  !*** ./src/Kernel/Engine.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Engine\": () => (/* binding */ Engine)\n/* harmony export */ });\n/* harmony import */ var _State__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./State */ \"./src/Kernel/State.js\");\n/* harmony import */ var _Scene_Scene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Scene/Scene */ \"./src/Scene/Scene.js\");\n/* harmony import */ var _Entity_Sprite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Entity/Sprite */ \"./src/Entity/Sprite.js\");\n/* harmony import */ var _Math_Vector2f__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Math/Vector2f */ \"./src/Math/Vector2f.js\");\n/* harmony import */ var _Input_Controller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Input/Controller */ \"./src/Input/Controller.js\");\n\n\n\n\n\nclass Engine {\n  /**\n   * Blank image data for refreshing.\n   */\n  static blank;\n  /**\n   * Engine constructor.\n   */\n\n  constructor(setup, gameplay) {\n    // Assign the global instance.\n    if (!Engine.getInstance()) {\n      Engine.setInstance(this);\n    } // Initialize any default values.\n\n\n    this.fps = 60;\n    this.setup = setup;\n    this.scene = new _Scene_Scene__WEBPACK_IMPORTED_MODULE_1__.Scene();\n    this.gameplay = gameplay;\n    this.isPaused = false;\n    this.controller = new _Input_Controller__WEBPACK_IMPORTED_MODULE_4__.Controller();\n    this.canvasLayer = 0;\n    this.canvasLayers = {};\n    this.canvasScale = 1.5;\n    this.canvasWidth = 640;\n    this.canvasHeight = 480;\n    this.canvasOffset = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_3__.Vector2f(0, 0);\n    this.rootElement = null; // Execute the setup process.\n\n    if (this.getSetup() instanceof Function) {\n      this.getSetup()(this);\n    } // Initialize the engine.\n\n\n    this.setCanvasLayer(this.canvasLayer).update();\n  }\n  /**\n   * Assigns the gameplay loop.\n   *\n   * @param game\n   * @returns this\n   */\n\n\n  setGameplay(game) {\n    if (!game instanceof Function) {\n      return this;\n    }\n\n    this.gameplay = game;\n    return this;\n  }\n  /**\n   * Returns the gameplay loop.\n   *\n   * @returns {Function|*}\n   */\n\n\n  getGameplay() {\n    return this.gameplay;\n  }\n  /**\n   * Assigns the setup process.\n   *\n   * @param setup\n   * @returns this\n   */\n\n\n  setSetup(setup) {\n    if (!setup instanceof Function) {\n      return this;\n    }\n\n    this.setup = setup;\n    return this;\n  }\n  /**\n   * Returns the current setup process.\n   *\n   * @returns {*|Function}\n   */\n\n\n  getSetup() {\n    return this.setup;\n  }\n  /**\n   * Returns the width of the canvas.\n   *\n   * @returns number\n   */\n\n\n  getCanvasWidth() {\n    return this.canvasWidth;\n  }\n  /**\n   * Returns the height of the canvas.\n   *\n   * @returns number\n   */\n\n\n  getCanvasHeight() {\n    return this.canvasHeight;\n  }\n  /**\n   * Returns the canvas scale.\n   *\n   * @returns {number}\n   */\n\n\n  getCanvasScale() {\n    return this.canvasScale;\n  }\n  /**\n   * Returns the canvas offset position.\n   *\n   * @returns {Vector2f}\n   */\n\n\n  getCanvasOffset() {\n    return this.canvasOffset;\n  }\n  /**\n   * Returns the current scene.\n   *\n   * @returns Scene\n   */\n\n\n  getScene() {\n    return this.scene;\n  }\n  /**\n   * Assigns the scene.\n   *\n   * @param scene\n   * @returns this\n   */\n\n\n  setScene(scene) {\n    if (!scene instanceof _Scene_Scene__WEBPACK_IMPORTED_MODULE_1__.Scene) {\n      return this;\n    }\n\n    this.scene = scene;\n    return this;\n  }\n  /**\n   * Returns the camera zoom.\n   *\n   * @returns {number}\n   */\n\n\n  static getZoom() {\n    return Engine.getInstance().getScene().getCamera().getZoom();\n  }\n  /**\n   * Applies an async delay.\n   *\n   * @param time\n   * @returns Promise<any>\n   */\n\n\n  sleep(time) {\n    return new Promise(resolve => setTimeout(resolve, time));\n  }\n  /**\n   * Refreshes the canvas.\n   *\n   * @returns this\n   */\n\n\n  refresh() {\n    if (!Engine.blank) {\n      Engine.blank = this.getContext().createImageData(this.getCanvasWidth(), this.getCanvasHeight());\n    }\n\n    [...document.querySelectorAll('canvas[data-layer]')].map(c => {\n      c.getContext('2d').beginPath();\n      c.getContext('2d').clearRect(0, 0, this.getCanvasWidth(), this.getCanvasHeight());\n    });\n    return this;\n  }\n  /**\n   * Performs the engine update.\n   */\n\n\n  async update() {\n    const timeStart = new Date(); // Render the scene.\n\n    this.refresh().getScene().draw(); // Execute the gameplay logic.\n\n    if (this.getGameplay() instanceof Function) {\n      this.getGameplay()(this);\n    } // Determine the delay period based on the elapsed time.\n\n\n    const timeEnd = new Date();\n    const timeElapsed = timeEnd - timeStart;\n    const frameDelay = 1000 / this.getFps() - timeElapsed;\n    await this.sleep(frameDelay); // Execute the loop.\n\n    if (!this.isPaused) {\n      this.update();\n    } // Engine.text((1000 / timeElapsed).toFixed(2), new Vector2f(5, 15), 8);\n\n  }\n  /**\n   * Returns the frame rate.\n   *\n   * @returns number\n   */\n\n\n  getFps() {\n    return this.fps;\n  }\n  /**\n   * Returns the keyboard controller.\n   *\n   * @returns Controller\n   */\n\n\n  getController() {\n    return this.controller;\n  }\n  /**\n   * Returns the canvas instance.\n   *\n   * @returns Element\n   */\n\n\n  getCanvas() {\n    return this.canvasLayers[this.canvasLayer];\n  }\n  /**\n   * Returns the canvas context.\n   *\n   * @returns CanvasRenderingContext2D\n   */\n\n\n  getContext() {\n    return this.getCanvas().getContext('2d');\n  }\n  /**\n   * Assigns the canvas layer\n   *\n   * @param layer\n   * @returns {Engine}\n   */\n\n\n  setCanvasLayer(layer) {\n    this.canvasLayer = layer;\n\n    if (!this.hasCanvasLayer(layer)) {\n      this.canvasLayers[layer] = document.createElement('canvas');\n      this.canvasLayers[layer].setAttribute('style', `transform: scale(${this.canvasScale}, ${this.canvasScale}) translate(${this.canvasOffset.getX()}px, ${this.canvasOffset.getY()}px);`);\n      this.canvasLayers[layer].setAttribute('width', this.getCanvasWidth());\n      this.canvasLayers[layer].setAttribute('height', this.getCanvasHeight());\n      this.canvasLayers[layer].setAttribute('data-layer', layer);\n      this.canvasLayers[layer].getContext('2d').imageSmoothingEnabled = false; // Sort the onscreen canvases.\n\n      this.getRootElement().appendChild(this.canvasLayers[layer]);\n      [...document.querySelectorAll('canvas[data-layer]')].sort((a, b) => parseInt(a.getAttribute('data-layer')) - parseInt(b.getAttribute('data-layer'))).map(c => this.getRootElement().appendChild(c));\n    }\n\n    return this;\n  }\n  /**\n   * Returns an individual canvas layer.\n   *\n   * @param layer\n   * @returns {*}\n   */\n\n\n  getCanvasLayer(layer) {\n    return this.canvasLayers[layer];\n  }\n  /**\n   * Returns the root game element.\n   *\n   * @returns {HTMLElement}\n   */\n\n\n  getRootElement() {\n    if (!this.rootElement) {\n      this.rootElement = document.getElementById('game');\n    }\n\n    return this.rootElement;\n  }\n  /**\n   * Indicates whether or not a canvas layer exists.\n   *\n   * @param layer\n   * @returns {boolean}\n   */\n\n\n  hasCanvasLayer(layer) {\n    return this.getCanvasLayers().hasOwnProperty(layer);\n  }\n  /**\n   * Returns all stored canvas layers.\n   *\n   * @returns {{}}\n   */\n\n\n  getCanvasLayers() {\n    return this.canvasLayers;\n  }\n  /**\n   * Renders text to the screen.\n   *\n   * @param value\n   * @param position\n   * @param size\n   * @param color\n   * @param opacity\n   * @returns this\n   */\n\n\n  static text(value, position, size, color, opacity) {\n    const context = Engine.getInstance().getContext(); // Organize default values.\n\n    size = size || 24;\n    color = color || '#ffffff';\n    position = position || new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_3__.Vector2f(0, 0);\n    context.font = `${size}px font`;\n    context.fillStyle = color; // Only apply an opacity mask if we have a value provided.\n\n    if (typeof opacity !== 'undefined') {\n      context.globalAlpha = opacity;\n    } // Render the text.\n\n\n    context.fillText(value, position.getX(), position.getY()); // Refresh the opacity mask.\n\n    if (context.globalAlpha !== 1) {\n      context.globalAlpha = 1;\n    }\n  }\n  /**\n   * Draws a rectangle to the canvas.\n   *\n   * @param position\n   * @param size\n   * @param color\n   * @param opacity\n   * @param variant\n   */\n\n\n  static rectangle(position, size, color, opacity, variant) {\n    const context = Engine.getInstance().getContext(); // Organize default values.\n\n    size = size || new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_3__.Vector2f(0, 0);\n    color = color || '#ffffff';\n    position = position || new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_3__.Vector2f(0, 0); // Only apply an opacity mask if we have a provided value.\n\n    if (typeof opacity !== 'undefined') {\n      context.globalAlpha = opacity;\n    } // Render the shape.\n\n\n    switch (variant) {\n      case 'Stroke':\n        context.strokeStyle = color;\n        context.strokeRect(position.getX(), position.getY(), size.getX(), size.getY());\n        break;\n\n      case 'Fill':\n      default:\n        context.fillStyle = color;\n        context.fillRect(position.getX(), position.getY(), size.getX(), size.getY());\n        break;\n    } // Refresh the opacity mask.\n\n\n    if (context.globalAlpha !== 1) {\n      context.globalAlpha = 1;\n    }\n  }\n  /**\n   * Used to draw an arbitrary sprite graphic to the canvas.\n   *\n   * @param sprite\n   */\n\n\n  static drawSprite(sprite) {\n    if (!sprite || !sprite instanceof _Entity_Sprite__WEBPACK_IMPORTED_MODULE_2__.Sprite) {\n      return;\n    }\n\n    sprite.setOffset(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_3__.Vector2f(0, 0));\n    let currentSize = sprite.getScaledSize();\n    let currentFrame = sprite.getAnimation().getFrame();\n    let currentPosition = sprite.getOffsetPosition();\n    let canvasPosition = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_3__.Vector2f(currentPosition.getX() + (sprite.getFlipX() ? sprite.getScaledSize().getX() : 0), currentPosition.getY() + (sprite.getFlipY() ? sprite.getScaledSize().getY() : 0));\n    Engine.getInstance().getContext().drawImage(sprite.getAnimation().getDomResource(), currentFrame.getX(), currentFrame.getY(), currentFrame.getW(), currentFrame.getH(), canvasPosition.getX(), canvasPosition.getY(), currentSize.getX(), currentSize.getY());\n  }\n  /**\n   * Finds an entity by name.\n   *\n   * @param name\n   * @returns Sprite\n   */\n\n\n  static getEntity(name) {\n    if (!Engine.getInstance()) {\n      return new _Entity_Sprite__WEBPACK_IMPORTED_MODULE_2__.Sprite();\n    }\n\n    return Engine.getInstance().getScene().getEntity(name);\n  }\n  /**\n   * Returns a scaled value.\n   *\n   * @param value\n   * @returns {Vector2f|number}\n   */\n\n\n  scale(value) {\n    if (value instanceof _Math_Vector2f__WEBPACK_IMPORTED_MODULE_3__.Vector2f) {\n      return new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_3__.Vector2f(this.scale(value.getX()), this.scale(value.getY()));\n    }\n\n    return value * Engine.getInstance().getScene().getCamera().getZoom();\n  }\n  /**\n   * Assigns the active engine instance.\n   *\n   * @param instance\n   */\n\n\n  static setInstance(instance) {\n    _State__WEBPACK_IMPORTED_MODULE_0__.State.setEngine(instance);\n  }\n  /**\n   * Returns the active engine instance.\n   *\n   * @returns Engine\n   */\n\n\n  static getInstance() {\n    return _State__WEBPACK_IMPORTED_MODULE_0__.State.getEngine();\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Kernel/Engine.js?");

/***/ }),

/***/ "./src/Kernel/State.js":
/*!*****************************!*\
  !*** ./src/Kernel/State.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"State\": () => (/* binding */ State)\n/* harmony export */ });\nclass State {\n  /**\n   * Returns the engine instance.\n   *\n   * @returns {Engine}\n   */\n  static getEngine() {\n    return window.Engine;\n  }\n  /**\n   * Assigns the engine.\n   *\n   * @param engine\n   */\n\n\n  static setEngine(engine) {\n    window.Engine = engine;\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Kernel/State.js?");

/***/ }),

/***/ "./src/Math/Matrix.js":
/*!****************************!*\
  !*** ./src/Math/Matrix.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Matrix\": () => (/* binding */ Matrix)\n/* harmony export */ });\n/* harmony import */ var _Vector2f__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector2f */ \"./src/Math/Vector2f.js\");\n/* harmony import */ var _Vector3f__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector3f */ \"./src/Math/Vector3f.js\");\n\n\nclass Matrix {\n  /**\n   * Matrix constructor.\n   *\n   * @param size\n   */\n  constructor(size) {\n    this.data = [];\n\n    if (!size || !size instanceof _Vector2f__WEBPACK_IMPORTED_MODULE_0__.Vector2f) {\n      return;\n    }\n\n    for (let y = 0; y < size.getY(); y++) {\n      let row = [];\n\n      for (let x = 0; x < size.getX(); x++) {\n        row.push(0);\n      }\n\n      this.data.push(row);\n    }\n  }\n  /**\n   * Creates a new matrix instance.\n   *\n   * @param size\n   * @returns {Matrix}\n   */\n\n\n  static create(size) {\n    return new Matrix(size);\n  }\n  /**\n   * Assigns a value to the specified position.\n   *\n   * @param position\n   * @param value\n   * @returns {Matrix}\n   */\n\n\n  setValue(position, value) {\n    if (!position instanceof _Vector2f__WEBPACK_IMPORTED_MODULE_0__.Vector2f) {\n      return this;\n    }\n\n    this.data[position.getY()][position.getX()] = value;\n    return this;\n  }\n  /**\n   * Returns the value at the specified position.\n   *\n   * @param position\n   * @returns {*}\n   */\n\n\n  getValue(position) {\n    if (!position instanceof _Vector2f__WEBPACK_IMPORTED_MODULE_0__.Vector2f) {\n      return this;\n    }\n\n    return this.getData()[position.getY()][position.getX()];\n  }\n  /**\n   * Assigns the entire data map.\n   *\n   * @param data\n   * @returns {Matrix}\n   */\n\n\n  setData(data) {\n    this.data = data;\n    return this;\n  }\n  /**\n   * Returns the stored data.\n   *\n   * @returns {Array}\n   */\n\n\n  getData() {\n    return this.data;\n  }\n  /**\n   * Casts the matrix as an array.\n   *\n   * @returns {Array}\n   */\n\n\n  asArray() {\n    let response = [];\n\n    for (let i = 0; i < this.getData().length; i++) {\n      for (let j = 0; j < this.getData()[i].length; j++) {\n        response.push(this.getData()[i][j]);\n      }\n    }\n\n    return response;\n  }\n  /**\n   * Retrieves the details about a matrix.\n   *\n   * @returns {Array}\n   */\n\n\n  getDetails() {\n    let response = [];\n\n    for (let i = 0; i < this.getData().length; i++) {\n      for (let j = 0; j < this.getData()[i].length; j++) {\n        response.push(new _Vector3f__WEBPACK_IMPORTED_MODULE_1__.Vector3f(j, i, this.getData()[i][j]));\n      }\n    }\n\n    return response;\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Math/Matrix.js?");

/***/ }),

/***/ "./src/Math/Vector2f.js":
/*!******************************!*\
  !*** ./src/Math/Vector2f.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Vector2f\": () => (/* binding */ Vector2f)\n/* harmony export */ });\nclass Vector2f {\n  /**\n   * Vector2f constructor.\n   *\n   * @param x\n   * @param y\n   */\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  /**\n   * Returns the assigned X value.\n   *\n   * @returns {*}\n   */\n\n\n  getX() {\n    return this.x;\n  }\n  /**\n   * Assigns an X value.\n   *\n   * @param x\n   * @returns {Vector2f}\n   */\n\n\n  setX(x) {\n    this.x = x;\n    return this;\n  }\n  /**\n   * Returns the assigned Y value.\n   *\n   * @returns {*}\n   */\n\n\n  getY() {\n    return this.y;\n  }\n  /**\n   * Assigns the Y value.\n   *\n   * @param y\n   * @returns {Vector2f}\n   */\n\n\n  setY(y) {\n    this.y = y;\n    return this;\n  }\n  /**\n   * Adds another vector.\n   *\n   * @param v\n   * @returns {Vector2f}\n   */\n\n\n  add(v) {\n    if (!v instanceof Vector2f) {\n      return this;\n    }\n\n    this.x += Math.abs(v.getX()) <= 0.01 ? 0 : v.getX();\n    this.y += Math.abs(v.getY()) <= 0.01 ? 0 : v.getY();\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Math/Vector2f.js?");

/***/ }),

/***/ "./src/Math/Vector3f.js":
/*!******************************!*\
  !*** ./src/Math/Vector3f.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Vector3f\": () => (/* binding */ Vector3f)\n/* harmony export */ });\nclass Vector3f {\n  /**\n   * Vector3f constructor.\n   *\n   * @param x\n   * @param y\n   * @param z\n   */\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n  /**\n   * Returns the X value.\n   *\n   * @returns {*}\n   */\n\n\n  getX() {\n    return this.x;\n  }\n  /**\n   * Returns the Y value.\n   *\n   * @returns {*}\n   */\n\n\n  getY() {\n    return this.y;\n  }\n  /**\n   * Returns the Z element.\n   *\n   * @returns {*}\n   */\n\n\n  getZ() {\n    return this.z;\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Math/Vector3f.js?");

/***/ }),

/***/ "./src/Math/Vector4f.js":
/*!******************************!*\
  !*** ./src/Math/Vector4f.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Vector4f\": () => (/* binding */ Vector4f)\n/* harmony export */ });\nclass Vector4f {\n  /**\n   * Vector4f constructor.\n   *\n   * @param x\n   * @param y\n   * @param w\n   * @param h\n   */\n  constructor(x, y, w, h) {\n    this.x = x;\n    this.y = y;\n    this.w = w;\n    this.h = h;\n  }\n  /**\n   * Returns the assigned X value.\n   *\n   * @returns {*}\n   */\n\n\n  getX() {\n    return this.x;\n  }\n  /**\n   * Assigns the X value.\n   *\n   * @param x\n   * @returns {Vector4f}\n   */\n\n\n  setX(x) {\n    this.x = x;\n    return this;\n  }\n  /**\n   * Returns the assigned Y value.\n   *\n   * @returns {*}\n   */\n\n\n  getY() {\n    return this.y;\n  }\n  /**\n   * Assigns the Y value.\n   *\n   * @param y\n   * @returns {Vector4f}\n   */\n\n\n  setY(y) {\n    this.y = y;\n    return this;\n  }\n  /**\n   * Returns the assigned W value.\n   *\n   * @returns {*}\n   */\n\n\n  getW() {\n    return this.w;\n  }\n  /**\n   * Assigns the W value.\n   *\n   * @param w\n   * @returns {Vector4f}\n   */\n\n\n  setW(w) {\n    this.w = w;\n    return this;\n  }\n  /**\n   * Returns the assigned H value.\n   *\n   * @returns {*}\n   */\n\n\n  getH() {\n    return this.h;\n  }\n  /**\n   * Assigns the H value.\n   *\n   * @param h\n   * @returns {Vector4f}\n   */\n\n\n  setH(h) {\n    this.h = h;\n    return this;\n  }\n  /**\n   * Adds another Vector4f\n   *\n   * @param v\n   * @returns {Vector4f}\n   */\n\n\n  add(v) {\n    if (!v instanceof Vector4f) {\n      return this;\n    }\n\n    this.x += v.getX();\n    this.y += v.getY();\n    this.w += v.getW();\n    this.h += v.getH();\n    return this;\n  }\n  /**\n   * Used to determine whether or not two Vectors are colliding.\n   *\n   * @param rect\n   * @returns {boolean}\n   */\n\n\n  isColliding(rect) {\n    if (!rect instanceof Vector4f) {\n      return false;\n    }\n\n    return this.getX() < rect.getX() + rect.getW() && this.getX() + this.getW() > rect.getX() && this.getY() < rect.getY() + rect.getH() && this.getY() + this.getH() > rect.getY();\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Math/Vector4f.js?");

/***/ }),

/***/ "./src/Resource/ImageResource.js":
/*!***************************************!*\
  !*** ./src/Resource/ImageResource.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ImageResource\": () => (/* binding */ ImageResource)\n/* harmony export */ });\n/* harmony import */ var _Resource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Resource */ \"./src/Resource/Resource.js\");\n\nclass ImageResource extends _Resource__WEBPACK_IMPORTED_MODULE_0__.Resource {\n  /**\n   * ImageResource constructor.\n   *\n   * @param src\n   */\n  constructor(src) {\n    super(src);\n    let element = new Image();\n\n    if (src) {\n      element.src = this.src;\n\n      element.onload = () => {\n        this.onLoad();\n      };\n    }\n\n    this.setElement(element);\n  }\n  /**\n   * Indicates whether or not the image is loaded.\n   *\n   * @returns {boolean}\n   */\n\n\n  isLoaded() {\n    return this.getElement().loaded;\n  }\n  /**\n   * Assigns the internal resource element.\n   *\n   * @param element\n   * @returns {this}\n   */\n\n\n  setElement(element) {\n    if (!element instanceof Image) {\n      return this;\n    }\n\n    this.element = element;\n    return this;\n  }\n  /**\n   * Returns the assigned element.\n   *\n   * @returns {HTMLImageElement}\n   */\n\n\n  getElement() {\n    if (!this.element || !this.element.complete) {\n      return new Image();\n    }\n\n    return this.element;\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Resource/ImageResource.js?");

/***/ }),

/***/ "./src/Resource/Resource.js":
/*!**********************************!*\
  !*** ./src/Resource/Resource.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Resource\": () => (/* binding */ Resource)\n/* harmony export */ });\nclass Resource {\n  /**\n   * Resource constructor.\n   *\n   * @param src\n   */\n  constructor(src) {\n    this.src = src;\n    this.events = [];\n  }\n  /**\n   * Indicates whether or not the resource is loaded.\n   *\n   * @returns {boolean}\n   */\n\n\n  isLoaded() {\n    return true;\n  }\n  /**\n   * Binds a new load event.\n   *\n   * @param event\n   * @returns {Resource}\n   */\n\n\n  addEvent(event) {\n    if (this.isLoaded()) {\n      event();\n    }\n\n    if (!event instanceof Function) {\n      return this;\n    }\n\n    this.events.push(event);\n    return this;\n  }\n  /**\n   * Returns the configured events.\n   *\n   * @returns {Array}\n   */\n\n\n  getEvents() {\n    return this.events;\n  }\n  /**\n   * Executes the on load procedure.\n   */\n\n\n  onLoad() {\n    const events = this.getEvents();\n\n    for (let i = 0; i < events.length; i++) {\n      events[i]();\n    }\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Resource/Resource.js?");

/***/ }),

/***/ "./src/Scene/Camera.js":
/*!*****************************!*\
  !*** ./src/Scene/Camera.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Camera\": () => (/* binding */ Camera)\n/* harmony export */ });\n/* harmony import */ var _Entity_Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity/Sprite */ \"./src/Entity/Sprite.js\");\n/* harmony import */ var _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Math/Vector2f */ \"./src/Math/Vector2f.js\");\n/* harmony import */ var _Animation_Timeline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Animation/Timeline */ \"./src/Animation/Timeline.js\");\n\n\n\nclass Camera {\n  /**\n   * Camera constructor.\n   */\n  constructor() {\n    this.zoom = 2;\n    this.shake = 0;\n    this.sprite = new _Entity_Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite();\n    this.timeline = new _Animation_Timeline__WEBPACK_IMPORTED_MODULE_2__.Timeline();\n    this.position = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f(0, 0);\n  }\n  /**\n   * Returns a new Camera instance.\n   *\n   * @returns {Camera}\n   */\n\n\n  static create() {\n    return new Camera();\n  }\n  /**\n   * Assigns the timeline.\n   *\n   * @param timeline\n   * @returns {Camera}\n   */\n\n\n  setTimeline(timeline) {\n    if (!timeline instanceof _Animation_Timeline__WEBPACK_IMPORTED_MODULE_2__.Timeline) {\n      return this;\n    }\n\n    this.timeline = timeline;\n    return this;\n  }\n  /**\n   * Returns the timeline.\n   *\n   * @returns {Timeline}\n   */\n\n\n  getTimeline() {\n    return this.timeline;\n  }\n  /**\n   * Assigns a camera shake.\n   *\n   * @param shake\n   * @returns {Camera}\n   */\n\n\n  setShake(shake) {\n    this.shake = shake;\n    return this;\n  }\n  /**\n   * Returns the shake amount.\n   *\n   * @returns {number}\n   */\n\n\n  getShake() {\n    return this.shake;\n  }\n  /**\n   * Returns the shake offset.\n   *\n   * @returns {number}\n   */\n\n\n  getShakeOffset() {\n    if (!this.getShake()) {\n      return 0;\n    }\n\n    return (Math.random() - 0.5) * this.getShake();\n  }\n  /**\n   * Assigns a linked sprite to the camera.\n   *\n   * @param sprite\n   * @returns {Camera}\n   */\n\n\n  setSprite(sprite) {\n    if (!sprite instanceof _Entity_Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite) {\n      return this;\n    }\n\n    this.sprite = sprite;\n    return this;\n  }\n  /**\n   * Returns the linked sprite.\n   *\n   * @returns {Sprite}\n   */\n\n\n  getSprite() {\n    return this.sprite;\n  }\n  /**\n   * Used to zoom in the camera.\n   *\n   * @param zoom\n   * @returns {Camera}\n   */\n\n\n  setZoom(zoom) {\n    this.zoom = zoom;\n    return this;\n  }\n  /**\n   * Returns the zoom value.\n   *\n   * @returns {number}\n   */\n\n\n  getZoom() {\n    return this.zoom;\n  }\n  /**\n   * Assigns the camera position.\n   *\n   * @param position\n   * @returns {Camera}\n   */\n\n\n  setPosition(position) {\n    if (!position instanceof _Math_Vector2f__WEBPACK_IMPORTED_MODULE_1__.Vector2f) {\n      return this;\n    }\n\n    this.position = position;\n    return this;\n  }\n  /**\n   * Returns the camera position.\n   *\n   * @returns {Vector2f}\n   */\n\n\n  getPosition() {\n    return this.position;\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Scene/Camera.js?");

/***/ }),

/***/ "./src/Scene/Scene.js":
/*!****************************!*\
  !*** ./src/Scene/Scene.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Scene\": () => (/* binding */ Scene)\n/* harmony export */ });\n/* harmony import */ var _Graphic_Layer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Graphic/Layer */ \"./src/Graphic/Layer.js\");\n/* harmony import */ var _Kernel_State__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Kernel/State */ \"./src/Kernel/State.js\");\n/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Camera */ \"./src/Scene/Camera.js\");\n/* harmony import */ var _Entity_Sprite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Entity/Sprite */ \"./src/Entity/Sprite.js\");\n/* harmony import */ var _Math_Vector2f__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Math/Vector2f */ \"./src/Math/Vector2f.js\");\n/* harmony import */ var _Math_Vector4f__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Math/Vector4f */ \"./src/Math/Vector4f.js\");\n\n\n\n\n\n\nclass Scene {\n  /**\n   * Scene constructor.\n   */\n  constructor() {\n    this.area = new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_4__.Vector2f(1000, 1000);\n    this.layers = [];\n    this.sprites = {};\n    this.cameras = {};\n    this.currentCamera = null;\n  }\n  /**\n   * Create a new Scene instance.\n   *\n   * @returns {Scene}\n   */\n\n\n  static create() {\n    return new Scene();\n  }\n  /**\n   * Returns all entities.\n   *\n   * @returns {Array}\n   */\n\n\n  getEntities() {\n    let entities = [];\n    this.getLayers().map(layer => {\n      layer.getTiles().map(tile => {\n        entities.push(tile);\n      });\n    });\n\n    for (let i in this.sprites) {\n      if (!this.sprites.hasOwnProperty(i)) {\n        continue;\n      }\n\n      if (!this.sprites[i].getVisible()) {\n        continue;\n      }\n\n      switch (true) {\n        case this.sprites[i].hasChildren():\n          this.sprites[i].getParticles().map(particle => {\n            entities.push(particle.getSprite());\n          });\n          break;\n\n        default:\n          entities.push(this.sprites[i]);\n          break;\n      }\n    }\n\n    return entities;\n  }\n  /**\n   * Returns all entities capable of collision events.\n   *\n   * @param root\n   * @returns {Array}\n   */\n\n\n  getNearbyEntities(root) {\n    let entities = [];\n\n    if (!root.getSolid()) {\n      return [];\n    }\n\n    let layer = null;\n    let layers = this.getLayers();\n\n    for (let i = 0; i < layers.length; i++) {\n      layer = layers[i];\n      let tiles = layer.getTiles();\n      let tile = null;\n\n      for (let j = 0; j < tiles.length; j++) {\n        tile = tiles[j];\n\n        if (tile === root) {\n          continue;\n        }\n\n        if (!tile.getSolid() && !tile.hasEvents()) {\n          continue;\n        }\n\n        if (!tile.getVisible()) {\n          continue;\n        }\n\n        if (!tile.isNearby(root, _Entity_Sprite__WEBPACK_IMPORTED_MODULE_3__.Sprite.getFlag('DetectionWindow'))) {\n          continue;\n        }\n\n        entities.push(tile);\n      }\n    }\n\n    for (let i in this.sprites) {\n      if (!this.sprites.hasOwnProperty(i)) {\n        continue;\n      }\n\n      if (this.sprites[i] === root) {\n        continue;\n      }\n\n      if (!this.sprites[i].getSolid() && !this.sprites[i].hasEvents()) {\n        continue;\n      }\n\n      if (!this.sprites[i].getVisible()) {\n        continue;\n      }\n\n      if (!this.sprites[i].isNearby(root, _Entity_Sprite__WEBPACK_IMPORTED_MODULE_3__.Sprite.getFlag('DetectionWindow'))) {\n        continue;\n      }\n\n      switch (true) {\n        case this.sprites[i].hasChildren():\n          this.sprites[i].getParticles().map(particle => {\n            entities.push(particle.getSprite());\n          });\n          break;\n\n        default:\n          entities.push(this.sprites[i]);\n          break;\n      }\n    }\n\n    return entities;\n  }\n  /**\n   * Indicates whether or not a camera exists.\n   *\n   * @param name\n   * @returns {boolean}\n   */\n\n\n  hasCamera(name) {\n    return this.getCameras().hasOwnProperty(name);\n  }\n  /**\n   * Returns the current camera name.\n   *\n   * @returns {string}\n   */\n\n\n  getCurrentCamera() {\n    return this.currentCamera;\n  }\n  /**\n   * Assigns the current camera.\n   *\n   * @param name\n   * @returns {Scene}\n   */\n\n\n  setCurrentCamera(name) {\n    this.currentCamera = name;\n    return this;\n  }\n  /**\n   * Returns all cameras.\n   *\n   * @returns {{}}\n   */\n\n\n  getCameras() {\n    return this.cameras;\n  }\n  /**\n   * Assigns all cameras.\n   *\n   * @param cameras\n   * @returns {Scene}\n   */\n\n\n  setCameras(cameras) {\n    if (!cameras instanceof Object) {\n      return this;\n    }\n\n    this.cameras = cameras;\n    return this;\n  }\n  /**\n   * Returns the assigned camera.\n   *\n   * @returns {Camera}\n   */\n\n\n  getCamera() {\n    if (!this.getCurrentCamera()) {\n      return new _Camera__WEBPACK_IMPORTED_MODULE_2__.Camera();\n    }\n\n    if (!this.hasCamera(this.getCurrentCamera())) {\n      return new _Camera__WEBPACK_IMPORTED_MODULE_2__.Camera();\n    }\n\n    return this.getCameras()[this.getCurrentCamera()];\n  }\n  /**\n   * Assigns the camera.\n   *\n   * @param name\n   * @param camera\n   * @returns this\n   */\n\n\n  addCamera(name, camera) {\n    if (!camera instanceof _Camera__WEBPACK_IMPORTED_MODULE_2__.Camera) {\n      return this;\n    }\n\n    this.cameras[name] = camera;\n\n    if (!this.getCurrentCamera()) {\n      this.setCurrentCamera(name);\n    }\n\n    return this;\n  }\n  /**\n   * Returns a sprite by identifier.\n   *\n   * @param name\n   * @returns Sprite\n   * @deprecated\n   */\n\n\n  getSprite(name) {\n    if (!this.hasSprite(name)) {\n      return new _Entity_Sprite__WEBPACK_IMPORTED_MODULE_3__.Sprite();\n    }\n\n    return this.getSprites()[name];\n  }\n  /**\n   * Indicates whether or not a sprite exists.\n   *\n   * @param name\n   * @returns {boolean}\n   */\n\n\n  hasSprite(name) {\n    return this.getSprites().hasOwnProperty(name);\n  }\n  /**\n   * Returns the internal sprite collector.\n   *\n   * @returns {{}}\n   */\n\n\n  getSprites() {\n    return this.sprites;\n  }\n  /**\n   * Assigns all scene sprites.\n   *\n   * @param sprites\n   * @returns {Scene}\n   */\n\n\n  setSprites(sprites) {\n    if (!sprites instanceof Object) {\n      return this;\n    }\n\n    this.sprites = sprites;\n    return this;\n  }\n  /**\n   * Returns an entity by name.\n   *\n   * @param name\n   * @returns {Sprite}\n   */\n\n\n  getEntity(name) {\n    return this.getSprite(name);\n  }\n  /**\n   * Registers a new sprite entity.\n   *\n   * @param name\n   * @param sprite\n   * @returns this\n   */\n\n\n  addEntity(name, sprite) {\n    if (sprite instanceof Function) {\n      sprite = sprite();\n    }\n\n    if (!sprite instanceof _Entity_Sprite__WEBPACK_IMPORTED_MODULE_3__.Sprite) {\n      return this;\n    }\n\n    this.sprites[name] = sprite;\n    return this;\n  }\n  /**\n   * Assigns the scene boundaries.\n   *\n   * @param area\n   * @returns {Scene}\n   */\n\n\n  setArea(area) {\n    if (!area instanceof _Math_Vector2f__WEBPACK_IMPORTED_MODULE_4__.Vector2f) {\n      return this;\n    }\n\n    this.area = area;\n    return this;\n  }\n  /**\n   * Returns the scene boundaries.\n   *\n   * @returns {Vector2f}\n   */\n\n\n  getArea() {\n    return this.area;\n  }\n  /**\n   * Registers a new layer.\n   *\n   * @param layer\n   * @returns {Scene}\n   */\n\n\n  addLayer(layer) {\n    if (layer instanceof Function) {\n      layer = layer();\n    }\n\n    if (!layer instanceof _Graphic_Layer__WEBPACK_IMPORTED_MODULE_0__.Layer) {\n      return this;\n    }\n\n    this.layers.push(layer);\n    return this;\n  }\n  /**\n   * Returns all layers assigned to the scene.\n   *\n   * @returns {Array}\n   */\n\n\n  getLayers() {\n    return this.layers;\n  }\n  /**\n   * Returns the camera boundaries.\n   *\n   * @returns {Vector4f}\n   */\n\n\n  getCameraBoundary() {\n    const engine = _Kernel_State__WEBPACK_IMPORTED_MODULE_1__.State.getEngine();\n    return new _Math_Vector4f__WEBPACK_IMPORTED_MODULE_5__.Vector4f(0, 0, engine.getScene().getArea().getX() - engine.getCanvasWidth() / this.getCamera().getZoom(), engine.getScene().getArea().getY() - engine.getCanvasHeight() / this.getCamera().getZoom());\n  }\n  /**\n   * Renders the scene.\n   */\n\n\n  draw() {\n    const engine = _Kernel_State__WEBPACK_IMPORTED_MODULE_1__.State.getEngine();\n    const camera = this.getCamera();\n    const layers = this.getLayers();\n    const boundary = this.getCameraBoundary();\n    camera.getTimeline().update();\n    camera.getPosition().add(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_4__.Vector2f((camera.getSprite().getCalculatedPosition().getX() - engine.getCanvasWidth() / 2) * 0.02, (camera.getSprite().getCalculatedPosition().getY() - engine.getCanvasHeight() / 2) * 0.02)); // Handle map boundaries.\n\n    if (camera.getPosition().getX() < boundary.getX()) {\n      camera.getPosition().setX(boundary.getX());\n    }\n\n    if (camera.getPosition().getY() < boundary.getY()) {\n      camera.getPosition().setY(boundary.getY());\n    }\n\n    if (camera.getPosition().getX() > boundary.getW()) {\n      camera.getPosition().setX(boundary.getW());\n    }\n\n    if (camera.getPosition().getY() > boundary.getH()) {\n      camera.getPosition().setY(boundary.getH());\n    } // Handle camera shake.\n\n\n    camera.getPosition().add(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_4__.Vector2f(camera.getShakeOffset(), camera.getShakeOffset()));\n    camera.getSprite().setOffset(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_4__.Vector2f(-camera.getPosition().getX(), -camera.getPosition().getY()));\n    let temperature = 10; // Update the current frame.\n\n    for (let z = _Entity_Sprite__WEBPACK_IMPORTED_MODULE_3__.Sprite.getZRange().getX(); z < layers.length * 10; z++) {\n      _Entity_Sprite__WEBPACK_IMPORTED_MODULE_3__.Sprite.setZCurrent(z);\n\n      for (let i = 0; i < layers.length; i++) {\n        if (i * 10 !== z) {\n          continue;\n        }\n\n        layers[i].setZIndex(i).setOffset(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_4__.Vector2f(-camera.getPosition().getX(), -camera.getPosition().getY())).draw();\n      }\n\n      for (let i in this.sprites) {\n        if (!this.sprites.hasOwnProperty(i)) {\n          continue;\n        }\n\n        if (this.sprites[i].getZIndex() === _Entity_Sprite__WEBPACK_IMPORTED_MODULE_3__.Sprite.getZCurrent() || this.sprites[i].hasChildren()) {\n          this.sprites[i].setOffset(new _Math_Vector2f__WEBPACK_IMPORTED_MODULE_4__.Vector2f(-camera.getPosition().getX(), -camera.getPosition().getY())).draw();\n        }\n      } // Apply any pixel transformations.\n      // let composite = engine.getCanvasLayer(Math.floor(z / 10)).getContext('2d').getImageData(0, 0, engine.getCanvasWidth(), engine.getCanvasHeight());\n      //\n      // for(let i = 0; i < composite.data.length; i += 4){\n      //     // Ignore any pixels without an opacity.\n      //     if(!composite.data[i + 3]){\n      //         continue;\n      //     }\n      //\n      //     // Apply temperature updates.\n      //     composite.data[i] = Math.min(composite.data[i] + temperature, 255);\n      //     composite.data[i + 1] = Math.min(composite.data[i + 1], 255);\n      //     composite.data[i + 2] = Math.min(composite.data[i + 2] + temperature, 255);\n      //\n      //     // Limit the color palette.\n      //     composite.data[i] = Math.min(Math.round(composite.data[i] / 20) * 20, 255);\n      //     composite.data[i + 1] = Math.min(Math.round(composite.data[i + 1] / 20) * 20, 255);\n      //     composite.data[i + 2] = Math.min(Math.round(composite.data[i + 2] / 20) * 20, 255);\n      // }\n      //\n      // engine.getCanvasLayer(z).getContext('2d').putImageData(composite, 0, 0);\n\n    }\n  }\n\n}\n\n//# sourceURL=webpack://charset/./src/Scene/Scene.js?");

/***/ }),

/***/ "./src/app.js":
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Example_Procedural_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Example/Procedural/Game */ \"./src/Example/Procedural/Game.js\");\n\nnew _Example_Procedural_Game__WEBPACK_IMPORTED_MODULE_0__.Game();\n\n//# sourceURL=webpack://charset/./src/app.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/app.js");
/******/ 	
/******/ })()
;